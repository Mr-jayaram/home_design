<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Floor Plan Designer</title>
    <link
        href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Playfair+Display:wght@700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <link rel="icon" href="data:,">
    <!-- Three.js for 3D View -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --primary-dark: #1e40af;
            --secondary: #7c3aed;
            --accent: #f59e0b;
            --bg-main: #0f172a;
            --bg-panel: #1e293b;
            --bg-card: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --border: #475569;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--bg-main);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, var(--bg-panel) 0%, var(--bg-card) 100%);
            border-bottom: 1px solid var(--border);
            padding: 0 10px;
            /* Reduced padding on mobile */
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 1001;
            overflow: hidden;
            /* Prevent header itself from scrolling */
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-family: 'Playfair Display', serif;
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .logo-icon {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-grow: 1;
            justify-content: flex-end;
            margin-left: 10px;
        }

        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'DM Sans', sans-serif;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(37, 99, 235, 0.4);
        }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-icon {
            padding: 10px;
            min-width: 40px;
            justify-content: center;
        }

        /* Mobile Menu Toggle */
        .mobile-toggle {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 30px;
            cursor: pointer;
            padding-right: 15px;
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* Left Sidebar */
        .sidebar-left {
            width: 280px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            overflow-y: auto;
            padding: 20px;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .sidebar-section {
            margin-bottom: 24px;
        }

        .sidebar-title {
            font-size: 13px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            padding: 8px 0;
            transition: color 0.2s;
        }

        .sidebar-title:hover {
            color: var(--primary);
        }

        .sidebar-title::after {
            content: '‚ñº';
            margin-left: auto;
            font-size: 10px;
            transition: transform 0.3s;
        }

        .sidebar-section.collapsed .sidebar-title::after {
            transform: rotate(-90deg);
        }

        .sidebar-section.collapsed>*:not(.sidebar-title) {
            display: none !important;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .tool-btn {
            background: var(--bg-card);
            border: 2px solid transparent;
            border-radius: 8px;
            padding: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .tool-btn:hover {
            background: var(--border);
            transform: translateY(-2px);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .tool-icon {
            font-size: 28px;
            margin-bottom: 6px;
            display: block;
        }

        .tool-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .tool-btn.active .tool-label {
            color: white;
        }

        /* Room Items */
        .room-item {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 14px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .room-item:hover {
            background: var(--border);
            transform: translateX(4px);
            border-color: var(--primary);
        }

        .room-item.placing {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-color: var(--primary);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }
        }

        .room-icon {
            font-size: 28px;
        }

        .room-info {
            flex: 1;
        }

        .room-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .room-item.placing .room-name {
            color: white;
        }

        .room-size {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .room-item.placing .room-size {
            color: rgba(255, 255, 255, 0.8);
        }

        /* Symbol Library */
        .symbol-item {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: move;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .symbol-item:hover {
            background: var(--border);
            transform: translateX(4px);
        }

        .symbol-icon {
            font-size: 24px;
            width: 40px;
            text-align: center;
        }

        .symbol-info {
            flex: 1;
        }

        .symbol-name {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .symbol-size {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Canvas Area */
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-main);
            position: relative;
            min-width: 0;
        }

        .canvas-toolbar {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 12px 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            overflow-x: auto;
        }

        .toolbar-group {
            display: flex;
            gap: 6px;
            align-items: center;
            padding: 0 12px;
            border-right: 1px solid var(--border);
            flex-shrink: 0;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-right: 6px;
        }

        .select-input {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
        }

        .canvas-wrapper {
            flex: 1;
            padding: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background:
                radial-gradient(circle at 20% 30%, rgba(37, 99, 235, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(124, 58, 237, 0.05) 0%, transparent 50%),
                var(--bg-main);
        }

        #designCanvas {
            background: white;
            border-radius: 4px;
            box-shadow:
                0 0 0 1px var(--border),
                0 10px 30px rgba(0, 0, 0, 0.1);
            cursor: crosshair;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: center center;
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
        }

        #zoomRange {
            width: 100px;
            cursor: pointer;
            accent-color: var(--primary);
        }

        /* 3D Container */
        #threeContainer {
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: var(--bg-main);
        }

        /* Right Sidebar */
        .sidebar-right {
            width: 300px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .property-group {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .property-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .property-row {
            margin-bottom: 12px;
        }

        .property-row:last-child {
            margin-bottom: 0;
        }

        .property-label {
            display: block;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .property-input {
            width: 100%;
            background: var(--bg-main);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
        }

        /* Layers Panel */
        .layer-item {
            background: var(--bg-main);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .layer-item:hover {
            background: var(--border);
        }

        .layer-visibility {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
        }

        .layer-name {
            flex: 1;
            font-size: 13px;
        }

        .layer-count {
            font-size: 11px;
            color: var(--text-secondary);
            background: var(--bg-card);
            padding: 2px 8px;
            border-radius: 12px;
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-panel);
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            border: 1px solid var(--border);
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 24px;
        }

        .modal-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-close {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--danger);
            color: white;
        }

        .modal-body {
            margin-bottom: 24px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .form-input {
            width: 100%;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'DM Sans', sans-serif;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .form-select {
            width: 100%;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            font-family: 'DM Sans', sans-serif;
        }

        .input-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .modal-footer {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .btn-cancel {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-cancel:hover {
            background: var(--border);
        }

        /* Dimension Grid in Sidebar */
        .dimension-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .dimension-item {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .dimension-label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .dimension-value {
            font-size: 16px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .dimension-unit {
            font-size: 10px;
            color: var(--text-secondary);
            margin-left: 2px;
        }

        .dimension-item.balance {
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(124, 58, 237, 0.1));
            border-color: var(--primary);
        }

        .dimension-item.balance .dimension-value {
            color: var(--primary);
        }

        /* Info Badge */
        .info-badge {
            display: inline-block;
            background: var(--bg-card);
            color: var(--text-secondary);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            margin-left: 8px;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-panel);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }

        /* Welcome Screen */
        .welcome-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .welcome-content {
            text-align: center;
            max-width: 500px;
            padding: 40px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .welcome-icon {
            font-size: 80px;
            margin-bottom: 20px;
        }

        .welcome-title {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 12px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .welcome-subtitle {
            font-size: 16px;
            color: var(--text-secondary);
            margin-bottom: 32px;
        }

        /* Notification Toast */
        .toast {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            z-index: 3000;
            display: none;
            align-items: center;
            gap: 12px;
            animation: slideInRight 0.3s ease;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .toast.active {
            display: flex;
        }

        .toast-icon {
            font-size: 24px;
        }

        .toast-message {
            font-size: 14px;
            color: var(--text-primary);
        }

        /* --- MOBILE RESPONSIVE CSS --- */
        @media (max-width: 992px) {
            .mobile-toggle {
                display: block;
            }

            .logo span {
                font-size: 18px;
            }

            .header-actions {
                overflow-x: auto;
                justify-content: flex-start;
                padding-bottom: 4px;
                /* Space for hidden scrollbar */
                -ms-overflow-style: none;
                /* IE and Edge */
                scrollbar-width: none;
                /* Firefox */
                flex-wrap: nowrap;
                mask-image: linear-gradient(to right, black 85%, transparent 100%);
            }

            .header-actions::-webkit-scrollbar {
                display: none;
                /* Hide scrollbar for Chrome, Safari, Opera */
            }

            .header-actions .btn {
                flex-shrink: 0;
            }

            .header-actions .btn:not(.btn-primary) {
                padding: 10px;
            }

            .header-actions .btn span:not(.logo-icon) {
                font-size: 16px;
            }

            .header-actions .btn span+span,
            .header-actions .btn:not(.btn-icon) span:not(:first-child) {
                display: none;
                /* Hide text on small buttons */
            }

            /* Move Sidebars to Slide-in Menus */
            .sidebar-left {
                position: fixed;
                left: -280px;
                top: 60px;
                height: calc(100vh - 60px);
                box-shadow: 10px 0 15px rgba(0, 0, 0, 0.3);
            }

            .sidebar-left.mobile-active {
                left: 0;
            }

            .sidebar-right {
                display: none;
                /* Combine with left sidebar on mobile */
            }

            /* If the left sidebar is open, show property panel at bottom of it */
            .sidebar-left.mobile-active .sidebar-section:last-child {
                border-top: 1px solid var(--border);
                padding-top: 20px;
            }

            .dimension-bar {
                grid-template-columns: repeat(2, 1fr);
                padding: 10px;
                gap: 10px;
            }

            .dimension-value {
                font-size: 16px;
            }

            .canvas-toolbar {
                padding: 8px 10px;
                gap: 10px;
            }

            .toolbar-group {
                padding: 0 6px;
            }

            /* Overlay for mobile sidebar */
            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 60px;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                z-index: 999;
            }

            .sidebar-overlay.active {
                display: block;
            }
        }

        @media (max-width: 480px) {
            .logo-icon {
                width: 32px;
                height: 32px;
            }

            .logo {
                display: none;

            }

            .logo span {
                display: none;
            }

            .dimension-bar {
                /* grid-template-columns: 1fr; */
                display: flex;
            }
        }

        /* 3D View Controls Overlay */
        .three-controls-overlay {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            z-index: 1005;
            width: auto;
            max-width: 95vw;
            pointer-events: none;
        }

        .three-controls-overlay>* {
            pointer-events: auto;
        }

        .three-control-btn.speed-ctrl {
            min-width: 140px;
        }

        .three-overlay-controls {
            display: flex;
            gap: 12px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(15px) saturate(180%);
            -webkit-backdrop-filter: blur(15px) saturate(180%);
            border-radius: 50px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15), inset 0 0 0 1px rgba(255, 255, 255, 0.4);
            border: none;
        }

        .three-control-btn {
            background: linear-gradient(135deg, var(--bg-panel) 0%, var(--bg-card) 100%);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 13px;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }

        .three-control-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(37, 99, 235, 0.2);
            background: white;
        }

        .three-control-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: 0 8px 20px rgba(37, 99, 235, 0.4);
        }

        .three-presets-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.6);

            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
        }

        .three-presets-grid .btn-secondary {
            font-size: 11px;
            padding: 8px 12px;
            border-radius: 12px;
            color: white;
            background: linear-gradient(135deg, var(--bg-panel) 0%, var(--bg-card) 100%);

            border: none;
            font-weight: 600;
            transition: all 0.2s;
        }

        .three-presets-grid .btn-secondary:hover {
            background: var(--primary);
            color: white;
            transform: scale(1.05);
        }

        @media (max-width: 992px) {
            .main-content {
                flex-direction: column !important;
                overflow-y: auto !important;
                height: auto !important;
            }

            .three-controls-overlay {
                bottom: 40px;
                /* Raised to avoid mobile browser bars */
                z-index: 2000;
            }

            .three-overlay-controls {
                flex-direction: column;
                padding: 12px;
                border-radius: 20px;
                width: 200px;
                align-items: stretch;
            }

            .three-control-btn {
                padding: 10px;
                width: 100%;
            }

            .three-presets-grid {
                grid-template-columns: repeat(2, 1fr);
                width: 200px;
            }

            /* Ensure canvas area is dominant on top in mobile */
            .main-content {
                display: flex;
                flex-direction: column;
            }

            .canvas-area {
                order: -1;
                /* Move to top of stack */
                height: 60vh;
                /* Fixed height for 3D on mobile */
                min-height: 400px;
            }

            .sidebar-left,
            .sidebar-right {
                order: 1;
            }
        }

        /* 3D Controls Toggle */
        .three-controls-toggle {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2005;
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 50px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
            display: none;
        }

        .three-controls-toggle:hover {
            background: var(--secondary);
            transform: translateX(-50%) translateY(-2px);
        }

        .three-controls-overlay.minimized {
            display: none !important;
        }

        .minimize-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }
    </style>
</head>

<body>
    <!-- Mobile Sidebar Overlay -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="toggleMobileMenu()"></div>

    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div style="display: flex; align-items: center;">
                <button class="mobile-toggle" onclick="toggleMobileMenu()">‚ò∞</button>
                <div class="logo">
                    <div class="logo-icon">üìê</div>
                    <span>FloorPlan Pro</span>
                </div>
            </div>

            <div class="header-actions">

                <button class="btn btn-secondary btn-icon" onclick="undo()" title="Undo (Ctrl+Z)">
                    <span>‚Ü∂</span>
                </button>
                <button class="btn btn-secondary btn-icon" onclick="redo()" title="Redo (Ctrl+Y)">
                    <span>‚Ü∑</span>
                </button>
                <button class="btn btn-secondary btn-icon" onclick="clearCanvas()" title="Clear">
                    <span>üóëÔ∏è</span>
                </button>
                <button class="btn btn-secondary" onclick="exportDesign()">
                    <span>üì§</span> <span>Export</span>
                </button>
                <button class="btn btn-secondary" onclick="loadProject()">
                    <span>üìÇ</span> <span>Import</span>
                </button>
                <input type="file" id="projectFileInput" style="display: none;" accept=".json"
                    onchange="handleFileUpload(event)">
                <button class="btn btn-secondary" onclick="saveProject()">
                    <span>üíæ</span> <span>Save</span>
                </button>
                <button id="viewToggleBtn" class="btn btn-primary" onclick="toggle3DView()"
                    style="background: linear-gradient(135deg, #7c3aed, #2563eb); border: none; box-shadow: 0 4px 12px rgba(124, 58, 237, 0.3);">
                    <span>üè†</span> <span id="viewToggleText">3D</span>
                </button>
            </div>
        </header>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Left Sidebar -->
            <aside class="sidebar-left" id="sidebarLeft">
                <!-- Floor Management -->
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        <span>üè¢</span> Floor Management
                    </div>
                    <button class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;"
                        onclick="openFloorModal()">
                        <span>‚ûï</span> Add Floor
                    </button>
                    <div id="floorListSidebar">
                        <!-- Floor items will be injected here -->
                    </div>
                </div>

                <!-- Drawing Tools -->
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        <span>üõ†Ô∏è</span> Drawing Tools
                    </div>
                    <div class="tool-grid">
                        <div class="tool-btn" onclick="selectTool('select')" id="tool-select">
                            <span class="tool-icon">üëÜ</span>
                            <div class="tool-label">Select</div>
                        </div>
                        <div class="tool-btn" onclick="selectTool('wall')" id="tool-wall">
                            <span class="tool-icon">üìè</span>
                            <div class="tool-label">Wall</div>
                        </div>
                        <div class="tool-btn" onclick="selectTool('door')" id="tool-door">
                            <span class="tool-icon">üö™</span>
                            <div class="tool-label">Door</div>
                        </div>
                        <div class="tool-btn" onclick="selectTool('window')" id="tool-window">
                            <span class="tool-icon">ü™ü</span>
                            <div class="tool-label">Window</div>
                        </div>
                        <div class="tool-btn" onclick="selectTool('dimension')" id="tool-dimension">
                            <span class="tool-icon">üìê</span>
                            <div class="tool-label">Dimension</div>
                        </div>
                        <div class="tool-btn" onclick="selectTool('text')" id="tool-text">
                            <span class="tool-icon">üìù</span>
                            <div class="tool-label">Text</div>
                        </div>
                        <div class="tool-btn" onclick="selectTool('eraser')" id="tool-eraser">
                            <span class="tool-icon">üßπ</span>
                            <div class="tool-label">Eraser</div>
                        </div>
                    </div>
                </div>


                <!-- Templates Library -->
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        <span>üèóÔ∏è</span> Quick Templates
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div class="symbol-item" draggable="true" ondragstart="dragSymbol(event, 'template_hall')"
                            onclick="pickItem('template_hall')" style="padding: 8px;">
                            <span class="symbol-icon"
                                style="background: rgba(139, 92, 246, 0.1); color: #8b5cf6; font-size: 16px;">üèõÔ∏è</span>
                            <div class="symbol-info">
                                <div class="symbol-name" style="font-size: 11px;">Hall</div>
                            </div>
                        </div>
                        <div class="symbol-item" draggable="true" ondragstart="dragSymbol(event, 'template_sitting')"
                            onclick="pickItem('template_sitting')" style="padding: 8px;">
                            <span class="symbol-icon"
                                style="background: rgba(244, 63, 94, 0.1); color: #f43f5e; font-size: 16px;">üõãÔ∏è</span>
                            <div class="symbol-info">
                                <div class="symbol-name" style="font-size: 11px;">Sitting</div>
                            </div>
                        </div>
                        <div class="symbol-item" draggable="true" ondragstart="dragSymbol(event, 'template_kitchen')"
                            onclick="pickItem('template_kitchen')" style="padding: 8px;">
                            <span class="symbol-icon"
                                style="background: rgba(245, 158, 11, 0.1); color: #f59e0b; font-size: 16px;">üç≥</span>
                            <div class="symbol-info">
                                <div class="symbol-name" style="font-size: 11px;">Kitchen</div>
                            </div>
                        </div>
                        <div class="symbol-item" draggable="true" ondragstart="dragSymbol(event, 'template_toilet')"
                            onclick="pickItem('template_toilet')" style="padding: 8px;">
                            <span class="symbol-icon"
                                style="background: rgba(6, 182, 212, 0.1); color: #06b6d4; font-size: 16px;">üöΩ</span>
                            <div class="symbol-info">
                                <div class="symbol-name" style="font-size: 11px;">Toilet</div>
                            </div>
                        </div>
                        <div class="symbol-item" draggable="true" ondragstart="dragSymbol(event, 'template_veranda')"
                            onclick="pickItem('template_veranda')" style="padding: 8px;">
                            <span class="symbol-icon"
                                style="background: rgba(16, 185, 129, 0.1); color: #10b981; font-size: 16px;">üåø</span>
                            <div class="symbol-info">
                                <div class="symbol-name" style="font-size: 11px;">Veranda</div>
                            </div>
                        </div>
                        <div class="symbol-item" draggable="true" ondragstart="dragSymbol(event, 'template_bedroom')"
                            onclick="pickItem('template_bedroom')" style="padding: 8px;">
                            <span class="symbol-icon"
                                style="background: rgba(59, 130, 246, 0.1); color: #3b82f6; font-size: 16px;">üõèÔ∏è</span>
                            <div class="symbol-info">
                                <div class="symbol-name" style="font-size: 11px;">Bedroom</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Stairs Library -->
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        <span>ü™ú</span> Stairs Library
                    </div>
                    <div class="symbol-item" draggable="true" ondragstart="dragSymbol(event, 'stair_straight')"
                        onclick="pickItem('stair_straight')">
                        <span class="symbol-icon">üìè</span>
                        <div class="symbol-info">
                            <div class="symbol-name">Straight Stairs</div>
                            <div class="symbol-size">10ft Length</div>
                        </div>
                    </div>
                    <div class="symbol-item" draggable="true" ondragstart="dragSymbol(event, 'stair_lshape')"
                        onclick="pickItem('stair_lshape')">
                        <span class="symbol-icon">üìê</span>
                        <div class="symbol-info">
                            <div class="symbol-name">L-Shape Stairs</div>
                            <div class="symbol-size">6ft x 6ft</div>
                        </div>
                    </div>
                    <div class="symbol-item" draggable="true" ondragstart="dragSymbol(event, 'stair_spiral')"
                        onclick="pickItem('stair_spiral')">
                        <span class="symbol-icon">üåÄ</span>
                        <div class="symbol-info">
                            <div class="symbol-name">Spiral Stairs</div>
                            <div class="symbol-size">6ft Diameter</div>
                        </div>
                    </div>
                </div>
                <!-- Furniture & Fixtures -->
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        <span>ü™ë</span> Furniture & Fixtures
                    </div>

                    <!-- Category Selector -->
                    <select id="furnitureCategorySelect" class="form-select"
                        onchange="filterFurnitureCategory(this.value)" style="margin-bottom: 12px; font-size: 13px;">
                        <option value="all">All Items</option>
                        <option value="hall">Living / Hall</option>
                        <option value="kitchen">Kitchen</option>
                        <option value="bedroom">Master Bedroom</option>
                        <option value="bathroom">Bathroom</option>
                        <option value="veranda">Veranda / Outdoor</option>
                    </select>

                    <div id="furnitureContainer" style="max-height: 400px; overflow-y: auto;">
                        <!-- Items will be visible based on category class -->

                        <!-- HALL / LIVING ROOM -->
                        <div class="symbol-item category-hall" draggable="true" ondragstart="dragSymbol(event, 'sofa')"
                            onclick="pickItem('sofa')">
                            <span class="symbol-icon material-symbols-outlined">chair</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Sofa Set</div>
                                <div class="symbol-size">3-Seater + 1</div>
                            </div>
                        </div>
                        <div class="symbol-item category-hall" draggable="true"
                            ondragstart="dragSymbol(event, 'tv_unit')" onclick="pickItem('tv_unit')">
                            <span class="symbol-icon material-symbols-outlined">tv</span>
                            <div class="symbol-info">
                                <div class="symbol-name">TV Unit</div>
                                <div class="symbol-size">Entertainment</div>
                            </div>
                        </div>
                        <div class="symbol-item category-hall" draggable="true" ondragstart="dragSymbol(event, 'table')"
                            onclick="pickItem('table')">
                            <span class="symbol-icon material-symbols-outlined">table_restaurant</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Coffee Table</div>
                                <div class="symbol-size">Center</div>
                            </div>
                        </div>
                        <div class="symbol-item category-hall category-bedroom" draggable="true"
                            ondragstart="dragSymbol(event, 'carpet')" onclick="pickItem('carpet')">
                            <span class="symbol-icon material-symbols-outlined">check_box_outline_blank</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Rug / Carpet</div>
                                <div class="symbol-size">6x4 ft</div>
                            </div>
                        </div>

                        <!-- KITCHEN -->
                        <div class="symbol-item category-kitchen" draggable="true"
                            ondragstart="dragSymbol(event, 'stove')" onclick="pickItem('stove')">
                            <span class="symbol-icon material-symbols-outlined">skillet</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Gas Stove</div>
                                <div class="symbol-size">4-Burner</div>
                            </div>
                        </div>
                        <div class="symbol-item category-kitchen" draggable="true"
                            ondragstart="dragSymbol(event, 'sink')" onclick="pickItem('sink')">
                            <span class="symbol-icon material-symbols-outlined">water_damage</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Kitchen Sink</div>
                                <div class="symbol-size">Double Bowl</div>
                            </div>
                        </div>
                        <div class="symbol-item category-kitchen" draggable="true"
                            ondragstart="dragSymbol(event, 'fridge')" onclick="pickItem('fridge')">
                            <span class="symbol-icon material-symbols-outlined">kitchen</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Refrigerator</div>
                                <div class="symbol-size">Double Door</div>
                            </div>
                        </div>
                        <div class="symbol-item category-kitchen" draggable="true"
                            ondragstart="dragSymbol(event, 'cabinet')" onclick="pickItem('cabinet')">
                            <span class="symbol-icon material-symbols-outlined">inventory_2</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Cabinet</div>
                                <div class="symbol-size">Storage</div>
                            </div>
                        </div>
                        <div class="symbol-item category-kitchen" draggable="true"
                            ondragstart="dragSymbol(event, 'dining_table')" onclick="pickItem('dining_table')">
                            <span class="symbol-icon material-symbols-outlined">table_bar</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Dining Table</div>
                                <div class="symbol-size">6-Seater</div>
                            </div>
                        </div>

                        <!-- MASTER BEDROOM -->
                        <div class="symbol-item category-bedroom" draggable="true"
                            ondragstart="dragSymbol(event, 'bed')" onclick="pickItem('bed')">
                            <span class="symbol-icon material-symbols-outlined">bed</span>
                            <div class="symbol-info">
                                <div class="symbol-name">King Bed</div>
                                <div class="symbol-size">72x78 inch</div>
                            </div>
                        </div>
                        <div class="symbol-item category-bedroom" draggable="true"
                            ondragstart="dragSymbol(event, 'bed_single')" onclick="pickItem('bed_single')">
                            <span class="symbol-icon material-symbols-outlined">single_bed</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Single Bed</div>
                                <div class="symbol-size">36x78 inch</div>
                            </div>
                        </div>
                        <div class="symbol-item category-bedroom" draggable="true"
                            ondragstart="dragSymbol(event, 'wardrobe')" onclick="pickItem('wardrobe')">
                            <span class="symbol-icon material-symbols-outlined">door_sliding</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Wardrobe</div>
                                <div class="symbol-size">Large Storage</div>
                            </div>
                        </div>
                        <div class="symbol-item category-bedroom" draggable="true"
                            ondragstart="dragSymbol(event, 'lamp')" onclick="pickItem('lamp')">
                            <span class="symbol-icon material-symbols-outlined">lamp</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Lamp Stand</div>
                                <div class="symbol-size">Corner</div>
                            </div>
                        </div>

                        <!-- BATHROOM -->
                        <div class="symbol-item category-bathroom" draggable="true"
                            ondragstart="dragSymbol(event, 'toilet')" onclick="pickItem('toilet')">
                            <span class="symbol-icon material-symbols-outlined">wc</span>
                            <div class="symbol-info">
                                <div class="symbol-name">WC / Commode</div>
                                <div class="symbol-size">Western</div>
                            </div>
                        </div>
                        <div class="symbol-item category-bathroom" draggable="true"
                            ondragstart="dragSymbol(event, 'washbasin')" onclick="pickItem('washbasin')">
                            <span class="symbol-icon material-symbols-outlined">wash</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Wash Basin</div>
                                <div class="symbol-size">Ceramic</div>
                            </div>
                        </div>
                        <div class="symbol-item category-bathroom" draggable="true"
                            ondragstart="dragSymbol(event, 'bathtub')" onclick="pickItem('bathtub')">
                            <span class="symbol-icon material-symbols-outlined">bathtub</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Bathtub</div>
                                <div class="symbol-size">Standard</div>
                            </div>
                        </div>
                        <div class="symbol-item category-bathroom" draggable="true"
                            ondragstart="dragSymbol(event, 'shower')" onclick="pickItem('shower')">
                            <span class="symbol-icon material-symbols-outlined">shower</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Shower Area</div>
                                <div class="symbol-size">Cubicle</div>
                            </div>
                        </div>

                        <!-- VERANDA / OUTDOOR -->
                        <div class="symbol-item category-veranda" draggable="true"
                            ondragstart="dragSymbol(event, 'plant')" onclick="pickItem('plant')">
                            <span class="symbol-icon material-symbols-outlined">potted_plant</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Potted Plant</div>
                                <div class="symbol-size">Large</div>
                            </div>
                        </div>
                        <div class="symbol-item category-veranda" draggable="true"
                            ondragstart="dragSymbol(event, 'bench')" onclick="pickItem('bench')">
                            <span class="symbol-icon material-symbols-outlined">chair_alt</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Garden Bench</div>
                                <div class="symbol-size">Wood/Iron</div>
                            </div>
                        </div>
                        <div class="symbol-item category-veranda" draggable="true"
                            ondragstart="dragSymbol(event, 'swing')" onclick="pickItem('swing')">
                            <span class="symbol-icon material-symbols-outlined">toys</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Swing</div>
                                <div class="symbol-size">Porch</div>
                            </div>
                        </div>
                        <div class="symbol-item category-veranda" draggable="true"
                            ondragstart="dragSymbol(event, 'compass')" onclick="pickItem('compass')">
                            <span class="symbol-icon">üß≠</span>
                            <div class="symbol-info">
                                <div class="symbol-name">Compass</div>
                                <div class="symbol-size">North</div>
                            </div>
                        </div>
                    </div>
                </div>


                <!-- Properties Panel (Merged for mobile) -->
                <div id="mobileProperties" class="sidebar-section">
                    <!-- This content is copied from sidebar-right logic for mobile view -->
                </div>
            </aside>

            <!-- Canvas Area -->
            <main class="canvas-area">
                <!-- Welcome Screen -->
                <div class="welcome-screen" id="welcomeScreen">
                    <div class="welcome-content">
                        <div class="welcome-icon">üèóÔ∏è</div>
                        <h1 class="welcome-title">Start Your Design</h1>
                        <p class="welcome-subtitle">Create a new project to begin designing your floor plan</p>
                        <button class="btn btn-primary" style="font-size: 16px; padding: 14px 28px;"
                            onclick="openProjectModal()">
                            <span>üìÑ</span> Create New Project
                        </button>
                    </div>
                </div>

                <!-- Virtual Joystick (Mobile Walk Mode) -->
                <div id="virtualJoystick"
                    style="display: none; position: absolute; bottom: 50px; left: 50px; width: 120px; height: 120px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.5); border-radius: 50%; touch-action: none; z-index: 1000;">
                    <div id="joystickKnob"
                        style="position: absolute; left: 35px; top: 35px; width: 50px; height: 50px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; pointer-events: none;">
                    </div>
                </div>
                <!-- Look Area Hint -->
                <div id="techLookHint"
                    style="display: none; position: absolute; top: 50%; right: 50px; transform: translateY(-50%); color: rgba(255,255,255,0.7); font-size: 14px; pointer-events: none; z-index: 1000;">
                    Swipe right side to look
                </div>

                <!-- Canvas Toolbar -->
                <div class="canvas-toolbar">
                    <div class="toolbar-group">
                        <span class="toolbar-label">Zoom:</span>
                        <input type="range" id="zoomRange" min="5" max="30" value="15" oninput="updateScale()">
                    </div>
                    <div class="toolbar-group">
                        <button class="btn btn-secondary btn-icon" onclick="toggleRotation()" title="Rotate View">
                            <span>üîÑ</span>
                        </button>
                        <button class="btn btn-secondary btn-icon" onclick="fitToScreen()" title="Fit to Screen">
                            <span>‚õ∂</span>
                        </button>
                        <button class="btn btn-secondary btn-icon" id="gridNumberToggle" onclick="toggleGridNumbers()"
                            title="Toggle Grid Numbers">
                            <span>üî¢</span>
                        </button>
                    </div>
                    <div class="toolbar-group">
                        <span class="toolbar-label">Grid:</span>
                        <select class="select-input" id="gridSelect" onchange="updateGrid()">
                            <option value="1" selected>1 ft</option>
                            <option value="2">2 ft</option>
                            <option value="0.5">0.5 ft</option>
                            <option value="0.25">0.25 ft</option>
                            <option value="0">Off</option>
                        </select>
                    </div>
                    <div class="toolbar-group">
                        <button class="btn btn-secondary btn-icon" onclick="toggleGrid()" title="Toggle Grid">
                            <span>‚äû</span>
                        </button>
                        <button class="btn btn-secondary btn-icon" onclick="toggleSnap()" title="Toggle Snap">
                            <span>üß≤</span>
                        </button>
                        <button class="btn btn-secondary btn-icon active" id="roomModeBtn" onclick="toggleRoomMode()"
                            title="Toggle Room Mode">
                            <span>üè†</span>
                        </button>
                        <button class="btn btn-secondary btn-icon active" id="measurementToggleBtn"
                            onclick="toggleMeasurements()" title="Toggle Measurements">
                            <span>üìè</span>
                        </button>
                    </div>
                </div>

                <div class="canvas-wrapper" style="position: relative;">
                    <canvas id="designCanvas"></canvas>
                    <div id="threeContainer" style="display: none; width: 100%; height: 100%;"></div>
                </div>

                <!-- 3D Controls Overlay -->
                <button id="threeControlsToggle" class="three-controls-toggle" onclick="toggleThreeControls()">
                    <span>üéÆ</span> 3D Controls
                </button>
                <div id="threeControls" class="three-controls-overlay  minimized" style="display: none;">
                    <button class="minimize-btn" onclick="toggleThreeControls()" title="Minimize">
                        <span class="material-symbols-outlined" style="font-size: 16px;">close</span>
                    </button>
                    <div class="three-overlay-controls">
                        <button class="three-control-btn" id="roofBtn" onclick="toggleRoof()" title="Toggle Roof">
                            <span class="material-symbols-outlined">roofing</span>
                            <span class="text">Roof: ON</span>
                        </button>
                        <button class="three-control-btn" id="walkBtn" onclick="toggleWalkMode()" title="Walk Mode">
                            <span class="material-symbols-outlined">directions_walk</span>
                            <span class="text">Walk: OFF</span>
                        </button>
                        <button class="three-control-btn" id="tourBtn" onclick="toggleTour()" title="Auto Tour">
                            <span class="material-symbols-outlined">play_circle</span>
                            <span class="text">Tour</span>
                        </button>
                        <button class="three-control-btn" id="recordBtn" onclick="toggleRecording()"
                            title="Record Video">
                            <span class="material-symbols-outlined">videocam</span>
                            <span class="text">Record</span>
                        </button>
                    </div>
                    <div class="three-presets-grid">
                        <button class="btn btn-secondary" onclick="set3DView('top')" title="Top View">
                            <span class="material-symbols-outlined">south</span> Top
                        </button>
                        <button class="btn btn-secondary" onclick="set3DView('front')" title="Front View">
                            <span class="material-symbols-outlined">north</span> Front
                        </button>
                        <button class="btn btn-secondary" onclick="set3DView('side')" title="Side View">
                            <span class="material-symbols-outlined">east</span> Side
                        </button>
                        <button class="btn btn-secondary" onclick="set3DView('iso')" title="Isometric View">
                            <span class="material-symbols-outlined">dynamic_feed</span> ISO
                        </button>
                    </div>
                </div>
            </main>

            <!-- Right Sidebar -->
            <aside class="sidebar-right" id="sidebarRight">
                <!-- Properties -->
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        <span>‚öôÔ∏è</span> Properties
                    </div>

                    <!-- Selection Edit Section -->
                    <div id="selectionProperties"
                        style="display: none; border: 2px solid #ef4444; border-radius: 12px; padding: 12px; margin-bottom: 16px; background: #fff1f2; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
                        <div class="property-title"
                            style="color: #ef4444; border-bottom-color: #fecaca; margin-bottom: 12px;">
                            <span id="selectedTypeIcon">‚öôÔ∏è</span> <span id="selectedTypeName">Selection</span>
                        </div>

                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <div class="tool-grid" style="grid-template-columns: 1fr 1fr; gap: 8px;">
                                <button class="btn btn-secondary" onclick="rotateSelected()" title="Rotate 90¬∞">
                                    <span>üîÑ</span> Rotate
                                </button>
                                <button class="btn btn-secondary" onclick="deleteSelected()"
                                    style="background: #ef4444; color: white; border: none;">
                                    <span>üóë</span> Delete
                                </button>
                            </div>

                            <!-- Color Property (Paint) -->
                            <div id="selectionColorRow"
                                style="display: none; border-top: 1px solid #fecaca; padding-top: 10px;">
                                <div
                                    style="font-size: 11px; font-weight: bold; color: #991b1b; margin-bottom: 6px; text-transform: uppercase;">
                                    Paint / Appearance</div>

                                <div id="singleColorCtrl">
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <input type="color" id="selectionColorPicker"
                                            onchange="changeSelectedColor('single')"
                                            style="width: 40px; height: 32px; border: 2px solid #fecaca; border-radius: 6px; cursor: pointer; padding: 0;">
                                        <span style="font-size: 13px; color: #7f1d1d;" id="colorLabel">Paint
                                            Color</span>
                                    </div>
                                </div>

                                <div id="dualColorCtrl" style="display: none; flex-direction: column; gap: 8px;">
                                    <!-- Inside Wall -->
                                    <div
                                        style="background: #fff0f0; padding: 6px; border-radius: 6px; border: 1px solid #fecaca;">
                                        <span
                                            style="font-size: 11px; font-weight: 600; color: #7f1d1d; display: block; margin-bottom: 4px;">Inside
                                            Wall</span>
                                        <div style="display: flex; gap: 4px; margin-bottom: 4px;">
                                            <input type="color" id="innerColorPicker"
                                                style="width: 32px; height: 32px; border: 1px solid #ccc; padding: 0;"
                                                oninput="updateSelectedWallColor('picker', 'inner')">
                                            <input type="text" id="innerColorHex" placeholder="#Hex"
                                                style="flex: 1; font-size: 11px; text-transform: uppercase; padding: 0 4px;"
                                                oninput="updateSelectedWallColor('hex', 'inner')">
                                        </div>
                                        <input type="text" id="innerColorRgb" placeholder="R, G, B"
                                            style="width: 100%; font-size: 11px; padding: 2px 4px;"
                                            oninput="updateSelectedWallColor('rgb', 'inner')">
                                    </div>

                                    <!-- Outside Wall -->
                                    <div
                                        style="background: #fff0f0; padding: 6px; border-radius: 6px; border: 1px solid #fecaca;">
                                        <span
                                            style="font-size: 11px; font-weight: 600; color: #7f1d1d; display: block; margin-bottom: 4px;">Outside
                                            Wall</span>
                                        <div style="display: flex; gap: 4px; margin-bottom: 4px;">
                                            <input type="color" id="outerColorPicker"
                                                style="width: 32px; height: 32px; border: 1px solid #ccc; padding: 0;"
                                                oninput="updateSelectedWallColor('picker', 'outer')">
                                            <input type="text" id="outerColorHex" placeholder="#Hex"
                                                style="flex: 1; font-size: 11px; text-transform: uppercase; padding: 0 4px;"
                                                oninput="updateSelectedWallColor('hex', 'outer')">
                                        </div>
                                        <input type="text" id="outerColorRgb" placeholder="R, G, B"
                                            style="width: 100%; font-size: 11px; padding: 2px 4px;"
                                            oninput="updateSelectedWallColor('rgb', 'outer')">
                                    </div>
                                </div>
                                <div id="selectionTextureCtrl" style="display: none; margin-top: 8px;">
                                    <label class="property-label" style="color: #991b1b; font-size: 10px;">Wall
                                        Texture</label>
                                    <select class="property-input" id="selectionTexture"
                                        onchange="applySelectedTexture(this.value)"
                                        style="background: white; border: 1px solid #fecaca;">
                                        <option value="">Plain / Paint</option>
                                        <option value="brick">Brick</option>
                                        <option value="wood">Wood</option>
                                        <option value="marble">Marble</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Scale Controls -->
                            <div id="scaleCtrls"
                                style="display: none; border-top: 1px solid #fecaca; padding-top: 10px;">
                                <div
                                    style="font-size: 11px; font-weight: bold; color: #991b1b; margin-bottom: 6px; text-transform: uppercase;">
                                    Adjust Size</div>

                                <div class="tool-grid"
                                    style="grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                                    <button class="btn btn-secondary" onclick="resizeSelected(0.9)"
                                        style="background: white; border: 1px solid #fecaca; font-size: 11px;">
                                        <span>‚ûñ</span> Scale Down
                                    </button>
                                    <button class="btn btn-secondary" onclick="resizeSelected(1.1)"
                                        style="background: white; border: 1px solid #fecaca; font-size: 11px;">
                                        <span>‚ûï</span> Scale Up
                                    </button>
                                </div>

                                <div style="display: flex; flex-direction: column; gap: 6px;">
                                    <div style="display: flex; gap: 6px;">
                                        <button class="btn btn-secondary" onclick="adjustDimension('width', -0.5)"
                                            style="flex: 1; font-size: 10px; padding: 6px;">Short Width</button>
                                        <button class="btn btn-secondary" onclick="adjustDimension('width', 0.5)"
                                            style="flex: 1; font-size: 10px; padding: 6px;">Long Width</button>
                                    </div>
                                    <div style="display: flex; gap: 6px;">
                                        <button class="btn btn-secondary" onclick="adjustDimension('length', -0.5)"
                                            style="flex: 1; font-size: 10px; padding: 6px;">Short Length</button>
                                        <button class="btn btn-secondary" onclick="adjustDimension('length', 0.5)"
                                            style="flex: 1; font-size: 10px; padding: 6px;">Long Length</button>
                                    </div>
                                </div>
                            </div>

                            <!-- Door Specific Controls -->
                            <div class="door-ctrl"
                                style="display: none; border-top: 1px solid #fecaca; padding-top: 10px;">
                                <div
                                    style="font-size: 11px; font-weight: bold; color: #991b1b; margin-bottom: 6px; text-transform: uppercase;">
                                    Door Orientation</div>
                                <div class="tool-grid" style="grid-template-columns: 1fr 1fr; gap: 8px;">
                                    <button class="btn btn-secondary" onclick="flipDoorSwing()"
                                        style="background: white; border: 1px solid #fecaca;">
                                        <span>‚áÖ</span> In / Out
                                    </button>
                                    <button class="btn btn-secondary" onclick="flipDoorHinge()"
                                        style="background: white; border: 1px solid #fecaca;">
                                        <span>‚áÑ</span> Left / Right
                                    </button>
                                </div>
                            </div>

                            <!-- Wall Specific Controls -->
                            <div id="wallHeightCtrl"
                                style="display: none; border-top: 1px solid #fecaca; padding-top: 10px;">
                                <div
                                    style="font-size: 11px; font-weight: bold; color: #991b1b; margin-bottom: 6px; text-transform: uppercase;">
                                    Wall Height (ft)</div>
                                <div style="display: flex; gap: 6px; align-items: center;">
                                    <input type="number" id="selectedWallHeight" class="property-input" min="1" max="50"
                                        step="0.5" onchange="updateSelectedWallHeight(this.value)"
                                        placeholder="Default">
                                    <span class="dimension-unit">ft</span>
                                </div>
                                <div style="font-size: 10px; color: #ef4444; margin-top: 4px;">Leave empty for floor
                                    height</div>
                            </div>
                        </div>
                    </div>
                    <div class="property-group">
                        <div class="property-title">Wall Settings</div>
                        <div class="property-row">
                            <label class="property-label">Thickness</label>
                            <div style="display: flex; flex-direction: column; gap: 8px; width: 100%;">
                                <div style="display: flex; gap: 6px;">
                                    <input type="number" class="property-input" id="wallThickness" value="0.5" min="0.1"
                                        max="2" step="0.1" style="flex: 1;" onchange="redrawAll()">
                                    <span class="dimension-unit">ft</span>
                                </div>
                                <div style="display: flex; gap: 4px;">
                                    <button class="btn btn-secondary" style="flex: 1; padding: 4px; font-size: 11px;"
                                        onclick="document.getElementById('wallThickness').value=0.5; redrawAll();">0.5
                                        ft</button>
                                    <button class="btn btn-secondary" style="flex: 1; padding: 4px; font-size: 11px;"
                                        onclick="document.getElementById('wallThickness').value=1.0; redrawAll();">1.0
                                        ft</button>
                                </div>
                            </div>
                        </div>
                        <div class="property-row">
                            <label class="property-label">Color</label>
                            <div style="display: flex; flex-direction: column; gap: 8px;">
                                <div style="display: flex; gap: 5px;">
                                    <input type="color" class="property-input" id="wallColor" value="#1e293b"
                                        style="flex: 1; height: 32px; padding: 0;" oninput="updateWallColor('picker')">
                                    <input type="text" class="property-input" id="wallColorHex" value="#1e293b"
                                        style="flex: 1; text-transform: uppercase;" placeholder="#Hex"
                                        oninput="updateWallColor('hex')">
                                </div>
                                <input type="text" class="property-input" id="wallColorRgb" value="30, 41, 59"
                                    placeholder="R, G, B" oninput="updateWallColor('rgb')">
                            </div>
                        </div>
                        <div class="property-row">
                            <label class="property-label">Texture</label>
                            <select class="property-input" id="wallTexture" onchange="updateWallTexture(this.value)">
                                <option value="">Plain Paint</option>
                                <option value="brick">Brick</option>
                                <option value="wood">Wood</option>
                                <option value="marble">Marble</option>
                            </select>
                        </div>
                        <div class="property-row">
                            <label class="property-label">Wall Alignment</label>
                            <select class="property-input" id="wallAlignment" onchange="redrawAll()">
                                <option value="center">Center</option>
                                <option value="outside">Outside (Outward)</option>
                                <option value="inside">Inside (Inward)</option>
                            </select>
                        </div>
                    </div>

                    <div class="property-group">
                        <div class="property-title">Floor Settings</div>
                        <div class="property-row">
                            <label class="property-label">Height (Elevation)</label>
                            <div style="display: flex; gap: 6px; width: 100%;">
                                <input type="number" class="property-input" id="floorHeight" value="10" min="5" max="25"
                                    step="1" onchange="updateFloorHeight(this.value)">
                                <span class="dimension-unit">ft</span>
                            </div>
                        </div>
                        <div class="property-row">
                            <label class="property-label">Material</label>
                            <select class="property-input" id="floorTextureSelect"
                                onchange="updateFloorTexture(this.value)">
                                <option value="">Default (White)</option>
                                <option value="wood">Polished Wood</option>
                                <option value="marble">White Marble</option>
                                <option value="tiles">Gray Tiles</option>
                            </select>
                        </div>
                        <div class="property-row" style="flex-direction: column; align-items: flex-start; gap: 8px;">
                            <label class="property-label">Upload Custom Floor</label>
                            <input type="file" id="floorImgInput" accept="image/*" class="property-input"
                                style="font-size: 11px; width: 100%; cursor: pointer;"
                                onchange="handle3DImageUpload(this, 'floor')">
                        </div>
                    </div>

                    <div class="property-group">
                        <div class="property-title">Door Settings</div>
                        <div class="property-row">
                            <label class="property-label">Type</label>
                            <select class="property-input" id="doorType">
                                <option value="single">Single</option>
                                <option value="double">Double</option>
                                <option value="sliding">Sliding</option>
                            </select>
                        </div>
                        <div class="property-row">
                            <label class="property-label">Width (ft)</label>
                            <input type="number" class="property-input" id="doorWidth" value="3" min="2" max="8">
                        </div>
                    </div>

                    <div class="property-group">
                        <div class="property-title">Window Settings</div>
                        <div class="property-row">
                            <label class="property-label"
                                style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="toggleWindowLabels" checked
                                    onchange="showWindowLabels = this.checked; redrawAll();">
                                Show Dimensions
                            </label>
                        </div>
                        <div class="property-row">
                            <label class="property-label">Type</label>
                            <select class="property-input" id="windowType">
                                <option value="standard">Standard</option>
                                <option value="bay">Bay</option>
                                <option value="sliding">Sliding</option>
                            </select>
                        </div>
                        <div class="property-row">
                            <label class="property-label">Width (ft)</label>
                            <input type="number" class="property-input" id="windowWidth" value="4" min="2" max="10">
                        </div>
                    </div>
                </div>

                <!-- 3D Environment -->
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        <span>üåç</span> 3D Environment (3D Only)
                    </div>
                    <div class="property-group">
                        <div class="property-row">
                            <label class="property-label">Presets</label>
                            <select class="property-input" onchange="setEnvPreset(this.value)">
                                <option value="">Choose Preset...</option>
                                <option value="garden">üè° Garden (Grass/Sky)</option>
                                <option value="modern">üè¢ Modern (Gray/White)</option>
                                <option value="sketch">‚úèÔ∏è Architectural Sketch</option>
                                <option value="night">üåô Night View</option>
                            </select>
                        </div>
                        <div class="property-row" style="flex-direction: column; align-items: flex-start; gap: 8px;">
                            <label class="property-label">Ground Texture</label>
                            <input type="file" id="groundImgInput" accept="image/*" class="property-input"
                                style="font-size: 11px; width: 100%; cursor: pointer;"
                                onchange="handle3DImageUpload(this, 'ground')">
                        </div>
                        <div class="property-row" style="flex-direction: column; align-items: flex-start; gap: 8px;">
                            <label class="property-label">360 Background</label>
                            <input type="file" id="envImgInput" accept="image/*" class="property-input"
                                style="font-size: 11px; width: 100%; cursor: pointer;"
                                onchange="handle3DImageUpload(this, 'env')">
                        </div>
                        <div
                            style="font-size: 10px; color: var(--text-secondary); margin-top: 4px; font-style: italic;">
                            * Images will only appear in 3D View
                        </div>
                    </div>
                </div>

                <!-- Layers Panel -->
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        <span>üóÇÔ∏è</span> Project Layers
                    </div>
                    <div class="property-group">
                        <div class="property-title">Floors</div>
                        <div id="floorLayersList">
                            <!-- Floor layers will be injected here -->
                        </div>
                    </div>
                    <div class="property-group">
                        <div class="property-title">Object Summary</div>
                        <div class="layer-item">
                            <span class="layer-name">üèóÔ∏è Home Boundary</span>
                            <span class="layer-count" id="homeCount">0</span>
                        </div>
                        <div class="layer-item">
                            <span class="layer-name">üè† Rooms</span>
                            <span class="layer-count" id="roomsCount">0</span>
                        </div>
                        <div class="layer-item">
                            <span class="layer-name">üìè Walls</span>
                            <span class="layer-count" id="wallCount">0</span>
                        </div>
                        <div class="layer-item">
                            <span class="layer-name">üö™ Doors & Windows</span>
                            <span class="layer-count" id="doorWindowCount">0</span>
                        </div>
                        <div class="layer-item">
                            <span class="layer-name">ü™ë Furniture</span>
                            <span class="layer-count" id="furnitureCount">0</span>
                        </div>
                    </div>
                </div>

                <!-- Project Stats -->
                <div class="sidebar-section">
                    <div class="sidebar-title">
                        <span>üìä</span> Project Stats
                    </div>
                    <div class="dimension-grid">
                        <div class="dimension-item">
                            <div class="dimension-label">Total Length</div>
                            <div class="dimension-value">
                                <span id="totalLength">0</span>
                                <span class="dimension-unit">ft</span>
                            </div>
                        </div>
                        <div class="dimension-item">
                            <div class="dimension-label">Total Breadth</div>
                            <div class="dimension-value">
                                <span id="totalBreadth">0</span>
                                <span class="dimension-unit">ft</span>
                            </div>
                        </div>
                        <div class="dimension-item balance">
                            <div class="dimension-label">Bal. Length</div>
                            <div class="dimension-value">
                                <span id="balanceLength">0</span>
                                <span class="dimension-unit">ft</span>
                            </div>
                        </div>
                        <div class="dimension-item balance">
                            <div class="dimension-label">Bal. Breadth</div>
                            <div class="dimension-value">
                                <span id="balanceBreadth">0</span>
                                <span class="dimension-unit">ft</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Eraser Settings (Hidden by default) -->
                <div class="sidebar-section" id="eraserSettings" style="display: none;">
                    <div class="sidebar-title">
                        <span>üßΩ</span> Eraser Settings
                    </div>
                    <div class="property-group">
                        <div class="property-row">
                            <label class="property-label">Eraser Size (ft)</label>
                            <input type="range" class="property-input" id="eraserSize" min="0.5" max="5" step="0.5"
                                value="1" oninput="updateEraserCursor()">
                            <div
                                style="display: flex; justify-content: space-between; font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                                <span>0.5ft</span>
                                <span id="eraserSizeVal">1ft</span>
                                <span>5ft</span>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>
        </div>

        <!-- Project Setup Modal -->
        <div class="modal-overlay" id="projectModal">
            <div class="modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>üèóÔ∏è</span> Project Setup
                    </h2>
                    <button class="modal-close" onclick="closeProjectModal()">√ó</button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Project Name</label>
                        <input type="text" class="form-input" id="projectNameInput" placeholder="My Dream Home"
                            value="My Dream Home">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Home Type</label>
                        <select class="form-select" id="homeType">
                            <option value="residential">Residential</option>
                            <option value="apartment">Apartment</option>
                            <option value="villa">Villa</option>
                            <option value="duplex">Duplex</option>
                            <option value="bungalow">Bungalow</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Home Dimensions</label>
                        <div class="input-group">
                            <div>
                                <label class="form-label" style="margin-bottom: 6px;">Length (feet)</label>
                                <input type="number" class="form-input" id="homeLength" placeholder="40" value="40"
                                    min="10" max="200">
                            </div>
                            <div>
                                <label class="form-label" style="margin-bottom: 6px;">Breadth (feet)</label>
                                <input type="number" class="form-input" id="homeBreadth" placeholder="30" value="30"
                                    min="10" max="200">
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Default Wall Thickness (ft)</label>
                        <input type="number" class="form-input" id="projectWallThickness" value="0.5" min="0.1" max="2"
                            step="0.1">
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-cancel" onclick="closeProjectModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="createProject()">
                        <span>‚úì</span> Create Project
                    </button>
                </div>
            </div>
        </div>

        <!-- Room Setup Modal -->
        <div class="modal-overlay" id="roomModal">
            <div class="modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span id="roomModalIcon">üõèÔ∏è</span>
                        <span id="roomModalTitle">Bedroom</span> Setup
                    </h2>
                    <button class="modal-close" onclick="closeRoomModal()">√ó</button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Room Name <span class="info-badge"
                                id="roomNameBadge">Bedroom</span></label>
                        <input type="text" class="form-input" id="roomName" placeholder="Master Bedroom">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Room Dimensions</label>
                        <div class="input-group">
                            <div>
                                <label class="form-label" style="margin-bottom: 6px;">Length (feet)</label>
                                <input type="number" class="form-input" id="roomLength" placeholder="12" value="12"
                                    min="4" max="50">
                            </div>
                            <div>
                                <label class="form-label" style="margin-bottom: 6px;">Breadth (feet)</label>
                                <input type="number" class="form-input" id="roomBreadth" placeholder="10" value="10"
                                    min="4" max="50">
                            </div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Wall Color</label>
                        <input type="color" class="form-input" id="roomColor" value="#2563eb"
                            style="height: 50px; cursor: pointer;">
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-cancel" onclick="closeRoomModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="saveRoom()">
                        <span>‚úì</span> Save & Place
                    </button>
                </div>
            </div>
        </div>

        <!-- Floor Setup Modal -->
        <div class="modal-overlay" id="floorModal">
            <div class="modal">
                <div class="modal-header">
                    <h2 class="modal-title">
                        <span>üè¢</span> Floor Setup
                    </h2>
                    <button class="modal-close" onclick="closeFloorModal()">√ó</button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Floor Name</label>
                        <input type="text" class="form-input" id="floorNameInput" placeholder="Ground Floor"
                            value="New Floor">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Floor Height (feet)</label>
                        <input type="number" class="form-input" id="floorHeightInput" value="10" min="5" max="20">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Elevation (feet)</label>
                        <input type="number" class="form-input" id="floorElevationInput" value="0" min="0" max="100">
                        <small style="color: var(--text-secondary); font-size: 11px;">Height from ground level</small>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Floor Dimensions (feet)</label>
                        <div class="input-group">
                            <div>
                                <label class="form-label" style="margin-bottom: 6px;">Length</label>
                                <input type="number" class="form-input" id="floorLengthInput" value="20" min="5"
                                    max="500">
                            </div>
                            <div>
                                <label class="form-label" style="margin-bottom: 6px;">Breadth</label>
                                <input type="number" class="form-input" id="floorBreadthInput" value="15" min="5"
                                    max="500">
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-cancel" onclick="closeFloorModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="addFloor()">
                        <span>‚úì</span> Add Floor
                    </button>
                </div>
            </div>
        </div>

        <!-- Toast Notification -->
        <div class="toast" id="toast">
            <span class="toast-icon">‚úì</span>
            <span class="toast-message" id="toastMessage"></span>
        </div>

        <script>
            const canvas = document.getElementById('designCanvas');
            const ctx = canvas.getContext('2d');

            // Application state
            let currentTool = null; // No tool selected by default
            let isDrawing = false;
            let isExporting = false;
            let startX, startY;
            let elements = []; // This will be synced with active floor
            let gridSnap = 15;

            // Furniture Filter Logic
            function filterFurnitureCategory(category) {
                const items = document.querySelectorAll('#furnitureContainer .symbol-item');
                items.forEach(item => {
                    if (category === 'all') {
                        item.style.display = 'flex';
                    } else {
                        if (item.classList.contains(`category-${category}`)) {
                            item.style.display = 'flex';
                        } else {
                            item.style.display = 'none';
                        }
                    }
                });
            }

            // ... [Existing code matches until exportDesign] ...

            function exportDesign() {
                if (!project.homeWall) {
                    showToast('‚ö†Ô∏è', 'Please create a project first!');
                    return;
                }

                // 1. Save State
                const savedState = {
                    width: canvas.width,
                    height: canvas.height,
                    scale: SCALE,
                    offsetX: offsetX,
                    offsetY: offsetY,
                    showGrid: showGrid,
                    showGridNumbers: showGridNumbers,
                    snap: snapEnabled
                };

                // 2. Setup High-Res Canvas for Export
                isExporting = true;
                showGrid = false;
                showGridNumbers = false;

                // A4 Landscape-ish Ratio (High Quality)
                canvas.width = 2400;
                canvas.height = 1600;

                // 3. Fit Project to "Print Area"
                // We leave margins for Header (Top) and Footer (Bottom)
                const margin = 100;
                const headerHeight = 200;
                const footerHeight = 150;
                const printAreaW = canvas.width - (margin * 2);
                const printAreaH = canvas.height - headerHeight - footerHeight;

                // Calculate bounding box of the home
                const homeW = project.homeWall.width / savedState.scale * SCALE; // Unscale then rescale? No, dimensions are static feet
                const projW_px = project.totalLength * 1; // Base units
                const projH_px = project.totalBreadth * 1;

                // Find scale to fit print area
                // We need to scale pixels_per_foot (SCALE) so that (totalLength * SCALE) fits in printAreaW
                const scaleX = printAreaW / project.totalLength;
                const scaleY = printAreaH / project.totalBreadth;
                SCALE = Math.floor(Math.min(scaleX, scaleY)); // New Export Scale

                // Center the project
                // The homeWall x,y are visual offsets in the canvas. 
                // In redrawAll, we translate by offsetX/Y. 
                // We want (offsetX + homeWall.x) to be centered.

                // Let's reset wall position for the export canvas center
                const wallPxW = project.totalLength * SCALE;
                const wallPxH = project.totalBreadth * SCALE;

                project.homeWall.x = (canvas.width - wallPxW) / 2;
                // Center vertically in the "content area" (between header and footer)
                project.homeWall.y = headerHeight + (printAreaH - wallPxH) / 2;

                // Reset panning
                offsetX = 0;
                offsetY = 0;

                // Sync other elements to new positions
                // Re-calculating all positions is complex because they are stored relative to canvas, not valid "project coordinates"
                // FIX: We need a smarter way or just shift everything.
                // Actually, `resizeCanvas` handles centering relative to wall delta. 
                // Let's manually shift all elements to match the new homeWall.x/y

                const dx = project.homeWall.x - savedState.originX_Ref; // We need original ref...
                // Fallback: We'll rely on the fact that `resizeCanvas` logic logic shifts everything if we call it?
                // No, `resizeCanvas` uses the *change* in center.

                // Let's recalculate relative positions based on the ratio
                // This is tricky. Simplified approach:
                // 1. Calculate relative positions of everything to the homeWall BEFORE changing it.
                // 2. Set new Scale/HomeWall
                // 3. Re-apply positions.

                // To be safe, we rely on the `updateScale` logic which handles rescaling.
                // But we changed canvas size manually.

                // Let's try leveraging updateScale logic but manually.
                const ratio = SCALE / savedState.scale;
                const oldHomeX = (savedState.width - (project.totalLength * savedState.scale)) / 2; // Roughly where it was centered
                const oldHomeY = (savedState.height - (project.totalBreadth * savedState.scale)) / 2;

                // Shift rooms/elements relative to new wall position
                project.rooms.forEach(room => {
                    const relX = (room.x - oldHomeX) / savedState.scale; // feet relative to corner
                    const relY = (room.y - oldHomeY) / savedState.scale;

                    room.width = room.length * SCALE;
                    room.height = room.breadth * SCALE;
                    room.x = project.homeWall.x + (relX * SCALE);
                    room.y = project.homeWall.y + (relY * SCALE);
                });

                elements.forEach(el => {
                    if (el.type !== 'text' && el.type !== 'symbol') {
                        // Lines
                        const rx1 = (el.x1 - oldHomeX) / savedState.scale;
                        const rx2 = (el.x2 - oldHomeX) / savedState.scale;
                        const ry1 = (el.y1 - oldHomeY) / savedState.scale;
                        const ry2 = (el.y2 - oldHomeY) / savedState.scale;

                        el.x1 = project.homeWall.x + (rx1 * SCALE);
                        el.x2 = project.homeWall.x + (rx2 * SCALE);
                        el.y1 = project.homeWall.y + (ry1 * SCALE);
                        el.y2 = project.homeWall.y + (ry2 * SCALE);
                    } else {
                        // Points
                        const rx = (el.x - oldHomeX) / savedState.scale;
                        const ry = (el.y - oldHomeY) / savedState.scale;
                        el.x = project.homeWall.x + (rx * SCALE);
                        el.y = project.homeWall.y + (ry * SCALE);
                    }
                });

                // 4. Draw The Plan
                redrawAll();

                // 5. Draw Header & Footer (Overlay)
                ctx.save();
                ctx.fillStyle = 'black'; // Text Color

                // HEADER: Skyline Real Estate Style
                ctx.textAlign = 'left';
                ctx.font = 'bold 60px "Playfair Display", serif';
                ctx.fillText('Skyline', margin, 100);

                ctx.font = 'bold 30px "DM Sans", sans-serif';
                ctx.fillStyle = '#475569';
                ctx.fillText('Real Estate', margin, 140);

                // Line under header
                ctx.beginPath();
                ctx.moveTo(margin, 160);
                ctx.lineTo(canvas.width - margin, 160);
                ctx.strokeStyle = '#e2e8f0';
                ctx.lineWidth = 2;
                ctx.stroke();

                // FOOTER: Disclaimer & Project Info
                const footerY = canvas.height - 80;

                // Disclaimer
                ctx.font = '20px "DM Sans", sans-serif';
                ctx.fillStyle = '#94a3b8';
                ctx.textAlign = 'left';
                const disclaimer = "This floor plan is for illustrative purposes only and is not drawn to scale. All measurements are approximate.";
                ctx.fillText(disclaimer, margin, footerY);

                // Right Side Info
                ctx.textAlign = 'right';
                ctx.fillStyle = 'black';
                ctx.font = 'bold 30px "DM Sans", sans-serif';
                ctx.fillText('Floor Plan', canvas.width - margin, footerY - 30);

                ctx.font = '24px "DM Sans", sans-serif';
                ctx.fillStyle = '#475569';
                ctx.fillText(project.name || 'Project Name', canvas.width - margin, footerY + 10);

                // Frame Border (Optional, like the image)
                ctx.strokeStyle = '#cbd5e1';
                ctx.lineWidth = 4;
                ctx.strokeRect(40, 40, canvas.width - 80, canvas.height - 80);

                ctx.restore();

                // 6. Download
                const link = document.createElement('a');
                link.download = `${project.name || 'floor-plan'}-professional.png`;
                link.href = canvas.toDataURL('image/png', 1.0);
                link.click();

                // 7. RESTORE STATE
                isExporting = false;
                canvas.width = savedState.width;
                canvas.height = savedState.height;
                SCALE = savedState.scale;
                offsetX = savedState.offsetX;
                offsetY = savedState.offsetY;
                showGrid = savedState.showGrid;
                showGridNumbers = savedState.showGridNumbers;

                // Restore positions requires inverse logic or just "Reset to Center" 
                // It's safer to just call fitToScreen() logic or re-center homeWall manually to old position.
                project.homeWall.x = oldHomeX; // Wait, this is tricky because we modified object props in place.
                // We need a robust restore.
                // Let's re-run the shift logic with inverse ratio.

                const invRatio = savedState.scale / SCALE; // Back to original scale
                // Current homeWall is centered in export canvas.
                // element.x is currently Export Coord.
                // We want to move it back to SavedState Coord.

                // But actually, HomeWall.x/y is just the top-left anchor.
                // Let's simply restore homeWall to oldHomeX/Y and scale everything back relative to it.

                const currentHomeX = project.homeWall.x;
                const currentHomeY = project.homeWall.y;

                project.homeWall.x = oldHomeX;
                project.homeWall.y = oldHomeY;

                project.rooms.forEach(room => {
                    const relX = (room.x - currentHomeX) / SCALE;
                    const relY = (room.y - currentHomeY) / SCALE;

                    room.width = room.length * savedState.scale;
                    room.height = room.breadth * savedState.scale;
                    room.x = oldHomeX + (relX * savedState.scale);
                    room.y = oldHomeY + (relY * savedState.scale);
                });

                elements.forEach(el => {
                    if (el.type !== 'text' && el.type !== 'symbol') {
                        const rx1 = (el.x1 - currentHomeX) / SCALE;
                        const rx2 = (el.x2 - currentHomeX) / SCALE;
                        const ry1 = (el.y1 - currentHomeY) / SCALE;
                        const ry2 = (el.y2 - currentHomeY) / SCALE;
                        el.x1 = oldHomeX + (rx1 * savedState.scale);
                        el.x2 = oldHomeX + (rx2 * savedState.scale);
                        el.y1 = oldHomeY + (ry1 * savedState.scale);
                        el.y2 = oldHomeY + (ry2 * savedState.scale);
                    } else {
                        const rx = (el.x - currentHomeX) / SCALE;
                        const ry = (el.y - currentHomeY) / SCALE;
                        el.x = oldHomeX + (rx * savedState.scale);
                        el.y = oldHomeY + (ry * savedState.scale);
                    }
                });

                redrawAll();
                showToast('‚úì', 'Professional Export Complete!');
            }

            // --- UPDATED DRAWING FUNCTIONS FOR EXPORT STYLE ---

            function toggleRoomMode() {
                showRoomMode = !showRoomMode;
                const btn = document.getElementById('roomModeBtn');
                if (btn) btn.classList.toggle('active', showRoomMode);
                redrawAll();
                showToast('üè†', `Room Mode: ${showRoomMode ? 'ON' : 'OFF'}`);
            }

            function drawAllRooms() {
                if (!showRoomMode && !isExporting) return;
                // pass 1: Backgrounds
                project.rooms.forEach(room => {
                    if (isExporting) {
                        // Export Style: Clean White Room, Black Outline
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(room.x, room.y, room.width, room.height);
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(room.x, room.y, room.width, room.height);
                    } else {
                        ctx.fillStyle = room.color + '20';
                        ctx.fillRect(room.x, room.y, room.width, room.height);
                    }
                });

                // pass 2: Labels
                project.rooms.forEach(room => {
                    if (!isExporting && room === selectedRoom) {
                        const wallThick = parseFloat(document.getElementById('wallThickness').value) * SCALE || (0.5 * SCALE);
                        ctx.save();
                        ctx.setLineDash([5, 5]);
                        ctx.strokeStyle = '#ef4444';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(room.x - wallThick / 2 - 4, room.y - wallThick / 2 - 4, room.width + wallThick + 8, room.height + wallThick + 8);
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(room.x + room.width + wallThick / 2 - 6, room.y + room.height + wallThick / 2 - 6, 12, 12);
                        ctx.restore();
                    }

                    if (isExporting) {
                        // Modern Black Text
                        ctx.fillStyle = '#000000';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Name
                        ctx.font = 'bold 24px "DM Sans"';
                        ctx.fillText(room.name, room.x + room.width / 2, room.y + room.height / 2 - 10);

                        // Dimensions
                        if (showMeasurements) {
                            ctx.font = '18px "DM Sans"';
                            const area = Math.round(room.length * room.breadth);
                            ctx.fillText(`${area} sq ft`, room.x + room.width / 2, room.y + room.height / 2 + 20);
                        }
                    } else {
                        ctx.font = '32px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(room.icon, room.x + room.width / 2, room.y + room.height / 2 - 15);
                        ctx.font = 'bold 14px DM Sans';
                        ctx.fillStyle = '#1e293b';
                        ctx.fillText(room.name, room.x + room.width / 2, room.y + room.height / 2 + 20);
                        if (showMeasurements) {
                            ctx.font = '11px DM Sans';
                            ctx.fillStyle = '#64748b';
                            ctx.fillText(`${room.length}' √ó ${room.breadth}'`, room.x + room.width / 2, room.y + room.height / 2 + 35);
                        }
                    }
                });
            }

            function drawDoor(x1, y1, x2, y2, preview, element = null) {
                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const thicknessFt = parseFloat(document.getElementById('wallThickness').value);
                const thickness = thicknessFt * SCALE;
                const flippedHinge = element?.flippedHinge || false;
                const flippedSwing = element?.flippedSwing || false;

                ctx.save();
                ctx.translate(x1, y1);
                ctx.rotate(angle);

                // Clear wall area
                ctx.fillStyle = 'white';
                ctx.fillRect(0, -thickness / 2, distance, thickness);

                // Handle Flips
                if (flippedHinge) { ctx.translate(distance, 0); ctx.scale(-1, 1); }
                if (flippedSwing) { ctx.scale(1, -1); }

                // Style
                const color = element?.color || (isExporting ? '#000000' : '#1e293b');
                ctx.strokeStyle = color;
                ctx.lineWidth = isExporting ? 3 : 2; // Thicker for print

                // Door Frame
                ctx.beginPath();
                ctx.moveTo(0, -thickness / 2);
                ctx.lineTo(0, thickness / 2);
                ctx.stroke();

                // Panel
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -distance);
                ctx.stroke();

                // Arc
                ctx.beginPath();
                ctx.lineWidth = isExporting ? 2 : 1;
                ctx.arc(0, 0, distance, 0, -Math.PI / 2, true);
                ctx.stroke();

                // Selection highlight for door
                if (selectedElement === element) {
                    ctx.save();
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = (isExporting ? 2 : 1) + 4;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(0, 0, distance + 5, 0, -Math.PI / 2, true);
                    ctx.stroke();
                    ctx.restore();
                }

                ctx.restore();

                // Labels (Skip if exporting to keep it clean, or add small)
                if (!preview && !isExporting) {
                    // ... [Existing Label Logic] ...
                }
            }

            function drawWindow(x1, y1, x2, y2, preview, element = null) {
                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const thicknessFt = parseFloat(document.getElementById('wallThickness').value);
                const thickness = thicknessFt * SCALE;

                ctx.save();
                ctx.translate(x1, y1);
                ctx.rotate(angle);

                ctx.fillStyle = 'white';
                ctx.fillRect(0, -thickness / 2, distance, thickness);

                const color = element?.color || (isExporting ? '#000000' : '#1e293b');
                ctx.strokeStyle = color;
                ctx.lineWidth = isExporting ? 3 : 1.5;
                ctx.strokeRect(0, -thickness / 2, distance, thickness);

                // If selected, add high contrast highlight
                if (selectedElement === element) {
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = (isExporting ? 3 : 1.5) + 4;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(0, -thickness / 2 - 2, distance, thickness + 4);
                    ctx.setLineDash([]);
                }

                ctx.beginPath();
                ctx.lineWidth = isExporting ? 2 : 1;
                ctx.moveTo(0, -thickness / 6);
                ctx.lineTo(distance, -thickness / 6);
                ctx.moveTo(0, thickness / 6);
                ctx.lineTo(distance, thickness / 6);
                ctx.stroke();

                ctx.restore();
            }

            function drawWallDimension(x1, y1, x2, y2, color) {
                if (!showMeasurements) return;
                if (isExporting) {
                    // Professional Simple Dimensions
                    const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    const lengthFt = (distance / SCALE).toFixed(1);
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    const angle = Math.atan2(y2 - y1, x2 - x1);

                    ctx.save();
                    ctx.translate(midX, midY);
                    let textAngle = angle;
                    if (textAngle > Math.PI / 2 || textAngle < -Math.PI / 2) textAngle += Math.PI;
                    ctx.rotate(textAngle);

                    ctx.translate(0, -20); // Offset above wall
                    ctx.font = '16px "DM Sans"';
                    ctx.fillStyle = '#000000';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${lengthFt}'`, 0, 0);

                    ctx.restore();
                    return;
                }
                // ... [Original Logic] ...
                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const lengthFt = (distance / SCALE).toFixed(1);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const angle = Math.atan2(y2 - y1, x2 - x1);

                ctx.save();
                ctx.translate(midX, midY);

                // Keep text readable (not upside down)
                let textAngle = angle;
                if (textAngle > Math.PI / 2 || textAngle < -Math.PI / 2) {
                    textAngle += Math.PI;
                }
                ctx.rotate(textAngle);

                // Offset text away from the wall line
                const offset = -25;
                ctx.translate(0, offset);

                // Enhanced font size and styling
                ctx.font = 'bold 14px DM Sans';
                const text = `${lengthFt} ft`;
                const tw = ctx.measureText(text).width;
                const padding = 8;

                // Enhanced Background with shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                ctx.fillRect(-tw / 2 - padding, -12, tw + padding * 2, 24);

                // Reset shadow for border
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // Enhanced Border
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(-tw / 2 - padding, -12, tw + padding * 2, 24);

                // Text with better contrast
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, 0);

                ctx.restore();
            } // Set to default SCALE (1 foot)
            let showGrid = true;
            let snapEnabled = true;
            let SCALE = 15; // pixels per foot
            let rotation = 0;
            let showGridNumbers = false;
            let showMeasurements = true;
            let showRoomMode = true; // Default room mode
            let offsetX = 0;
            let offsetY = 0;
            let lastTouchX = 0;
            let lastTouchY = 0;
            let isPanning = false;
            let showWindowLabels = true;
            let selectedElement = null;
            let selectedRoom = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            let isMovingElement = false;
            let isResizing = false;
            let initialPinchDist = 0;
            let initialPinchScale = 0;
            let mouseX = 0;
            let mouseY = 0;

            // History Stacks
            let undoStack = [];
            let redoStack = [];

            // Default Assets - Replace these paths with your actual images
            const DEFAULT_GROUND_IMG = 'grass.avif'; // Example: 'path/to/grass.jpg'
            const DEFAULT_ENV_IMG = 'sky.avif';    // Example: 'path/to/sky.jpg'
            const DEFAULT_FLOOR_IMG = 'tiles.jpg';         // Path to default floor texture

            // Material Assets (Three.js Textures)
            const ASSETS = {
                brick: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_diffuse.jpg',
                wood: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/hardwood2_diffuse.jpg',
                marble: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg',
                tiles: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/grid.png'
            };

            // Project state
            let project = {
                name: '',
                type: '',
                totalLength: 0,
                totalBreadth: 0,
                floors: [
                    {
                        id: 'floor_0',
                        name: 'Ground Floor',
                        elevation: 0,
                        height: 10,
                        elements: [],
                        rooms: [],
                        homeWall: null,
                        floorTexture: ''
                    }
                ],
                activeFloorIndex: 0,
                rooms: [],
                homeWall: null,
                groundTexture: DEFAULT_GROUND_IMG || null,
                envTexture: DEFAULT_ENV_IMG || null,
                defaultWallColor: '#1e293b',
                defaultWallTexture: '',
                defaultFloorTexture: DEFAULT_FLOOR_IMG || ''
            };

            // Image objects for 2D rendering
            let groundImageObj = null;
            if (DEFAULT_GROUND_IMG) {
                groundImageObj = new Image();
                groundImageObj.src = DEFAULT_GROUND_IMG;
                groundImageObj.onload = () => redrawAll();
            }

            // Reactive references for legacy code
            let elementsRef = project.floors[0].elements;

            function syncActiveFloor() {
                const activeFloor = project.floors[project.activeFloorIndex];
                elements = activeFloor.elements;
                // project.rooms is used globally, so we need to be careful.
                // Many functions use project.rooms directly. We'll shadow it or sync it.
            }

            function openFloorModal() {
                document.getElementById('floorNameInput').value = `Floor ${project.floors.length}`;
                document.getElementById('floorElevationInput').value = project.floors[project.floors.length - 1].elevation + project.floors[project.floors.length - 1].height;
                document.getElementById('floorLengthInput').value = project.totalLength;
                document.getElementById('floorBreadthInput').value = project.totalBreadth;
                document.getElementById('floorModal').classList.add('active');
            }

            function closeFloorModal() {
                document.getElementById('floorModal').classList.remove('active');
            }

            function handle3DImageUpload(input, type) {
                const file = input.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function (e) {
                    const dataUrl = e.target.result;
                    if (type === 'ground') {
                        project.groundTexture = dataUrl;
                        groundImageObj = new Image();
                        groundImageObj.src = dataUrl;
                        groundImageObj.onload = () => redrawAll();
                        showToast('üå±', 'Ground texture updated!');
                    } else if (type === 'env') {
                        project.envTexture = dataUrl;
                        showToast('üñºÔ∏è', 'Environment background updated!');
                    } else if (type === 'floor') {
                        const activeFloor = project.floors[project.activeFloorIndex];
                        activeFloor.floorTexture = dataUrl;
                        showToast('üè¢', 'Floor texture updated!');
                    }

                    // If in 3D mode, re-initialize to show changes
                    if (is3DMode) init3D();
                    redrawAll();
                };
                reader.readAsDataURL(file);
            }

            function addFloor() {
                const name = document.getElementById('floorNameInput').value || 'New Floor';
                const height = parseInt(document.getElementById('floorHeightInput').value) || 10;
                const elevation = parseInt(document.getElementById('floorElevationInput').value) || 0;
                const length = parseInt(document.getElementById('floorLengthInput').value) || project.totalLength;
                const breadth = parseInt(document.getElementById('floorBreadthInput').value) || project.totalBreadth;

                // Calculate x, y for the new floor's homeWall to center it
                const wallWidth = length * SCALE;
                const wallHeight = breadth * SCALE;
                const x = (canvas.width - wallWidth) / 2;
                const y = (canvas.height - wallHeight) / 2;

                const newFloor = {
                    id: 'floor_' + Date.now(),
                    name: name,
                    elevation: elevation,
                    height: height,
                    length: length,
                    breadth: breadth,
                    elements: [],
                    rooms: [],
                    homeWall: null
                };

                project.floors.push(newFloor);
                updateFloorUI();
                closeFloorModal();
                showToast('üè¢', `Floor "${name}" added`);
                switchFloor(project.floors.length - 1);
            }

            function switchFloor(index) {
                // Save current state if needed
                project.activeFloorIndex = index;
                const activeFloor = project.floors[index];

                elements = activeFloor.elements;
                // We need to make project.rooms point to activeFloor.rooms
                // But project is a const or let object.
                // We'll update project.rooms in place.
                project.rooms = activeFloor.rooms;
                project.homeWall = activeFloor.homeWall;
                project.totalLength = activeFloor.length;
                project.totalBreadth = activeFloor.breadth;

                updateFloorUI();
                redrawAll();
                updateLayerCounts();
                updateDimensionDisplay();

                showToast('üè¢', `Switched to ${activeFloor.name}`);
            }

            function updateFloorUI() {
                const sidebarList = document.getElementById('floorListSidebar');
                const layersList = document.getElementById('floorLayersList');

                if (!sidebarList || !layersList) return;

                sidebarList.innerHTML = '';
                layersList.innerHTML = '';

                project.floors.forEach((floor, index) => {
                    const isActive = index === project.activeFloorIndex;

                    // Sidebar List Item
                    const item = document.createElement('div');
                    item.className = `room-item ${isActive ? 'placing' : ''}`;
                    item.onclick = () => switchFloor(index);
                    item.innerHTML = `
                    <span class="room-icon">üè¢</span>
                    <div class="room-info">
                        <div class="room-name">${floor.name}</div>
                        <div class="room-size">Elev: ${floor.elevation}ft | H: ${floor.height}ft</div>
                    </div>
                `;
                    sidebarList.appendChild(item);

                    // Right Sidebar Layer Item
                    const layer = document.createElement('div');
                    layer.className = `layer-item ${isActive ? 'active' : ''}`;
                    if (isActive) layer.style.borderColor = 'var(--primary)';
                    layer.onclick = () => switchFloor(index);
                    layer.innerHTML = `
                    <span class="layer-visibility">üëÅÔ∏è</span>
                    <span class="layer-name">${floor.name}</span>
                    <span class="layer-count">${floor.rooms.length + floor.elements.length}</span>
                    <button class="btn-icon" style="background:none; border:none; color:var(--danger); cursor:pointer;" onclick="event.stopPropagation(); deleteFloor(${index})">üóëÔ∏è</button>
                `;
                    layersList.appendChild(layer);
                });
            }

            function deleteFloor(index) {
                if (project.floors.length <= 1) {
                    showToast('‚ö†Ô∏è', 'Cannot delete the only floor');
                    return;
                }
                if (confirm(`Are you sure you want to delete floor "${project.floors[index].name}"?`)) {
                    project.floors.splice(index, 1);
                    if (project.activeFloorIndex >= project.floors.length) {
                        project.activeFloorIndex = project.floors.length - 1;
                    }
                    switchFloor(project.activeFloorIndex);
                }
            }

            // Room configuration
            const roomConfig = {
                bedroom: { icon: 'üõèÔ∏è', name: 'Bedroom', defaultLength: 12, defaultBreadth: 10, color: '#3b82f6' },
                kitchen: { icon: 'üç≥', name: 'Kitchen', defaultLength: 10, defaultBreadth: 8, color: '#f59e0b' },
                toilet: { icon: 'üöΩ', name: 'Toilet', defaultLength: 6, defaultBreadth: 5, color: '#06b6d4' },
                hall: { icon: 'üèõÔ∏è', name: 'Hall', defaultLength: 15, defaultBreadth: 12, color: '#8b5cf6' },
                veranda: { icon: 'üåø', name: 'Veranda', defaultLength: 8, defaultBreadth: 4, color: '#10b981' },
                sitting: { icon: 'üõãÔ∏è', name: 'Sitting Area', defaultLength: 12, defaultBreadth: 12, color: '#f43f5e' }
            };

            // Symbol/Furniture definitions
            // using Material Symbols Outlined
            const symbols = {
                compass: { isCompass: true, width: 60, height: 60 },
                // Hall
                sofa: { icon: 'chair', width: 60, height: 60, label: 'Sofa' }, // chair maps to a sofa-ish icon or similar
                tv_unit: { icon: 'tv', width: 80, height: 30, label: 'TV' },
                table: { icon: 'table_restaurant', width: 60, height: 60, label: 'Table' },
                carpet: { icon: 'check_box_outline_blank', width: 100, height: 70, label: 'Rug' }, // Generic placeholder

                // Kitchen
                stove: { icon: 'skillet', width: 40, height: 40, label: 'Stove' }, // or 'stove' if available, 'outdoor_grill'
                sink: { icon: 'water_damage', width: 40, height: 40, label: 'Sink' }, // 'water_damage' looks like splash
                fridge: { icon: 'kitchen', width: 40, height: 60, label: 'Ref' },
                cabinet: { icon: 'inventory_2', width: 40, height: 40, label: 'Cab' },
                dining_table: { icon: 'table_bar', width: 80, height: 80, label: 'Dining' },

                // Bedroom
                bed: { icon: 'bed', width: 80, height: 80, label: '' },
                bed_single: { icon: 'single_bed', width: 50, height: 80, label: '' },
                wardrobe: { icon: 'door_sliding', width: 80, height: 30, label: 'Wardrobe' },
                lamp: { icon: 'lamp', width: 30, height: 30, label: '' },

                // Bathroom
                toilet: { icon: 'wc', width: 40, height: 40, label: '' }, // 'wc' is standard
                washbasin: { icon: 'wash', width: 40, height: 30, label: 'Basin' },
                bathtub: { icon: 'bathtub', width: 80, height: 40, label: '' },
                shower: { icon: 'shower', width: 40, height: 40, label: '' },

                // Veranda
                plant: { icon: 'potted_plant', width: 30, height: 30, label: '' },
                bench: { icon: 'chair_alt', width: 80, height: 30, label: 'Bench' },
                swing: { icon: 'toys', width: 60, height: 30, label: 'Swing' }, // 'toys' or similar

                // Stairs
                stair_straight: { isStair: true, stairType: 'straight', width: 3, length: 10, steps: 10 },
                stair_lshape: { isStair: true, stairType: 'lshape', width: 3, length: 6, breadth: 6, steps: 12 },
                stair_spiral: { isStair: true, stairType: 'spiral', radius: 3, steps: 12 }
            };

            let selectedRoomType = null;
            let currentRoom = null;
            let placingRoom = false; // Kept for legacy compatibility if needed
            let placingItemType = null; // New: holds the type of item being placed via Click/Tap

            function pickItem(type) {
                placingItemType = type;

                // Auto-close sidebar on mobile
                const sidebar = document.getElementById('sidebarLeft');
                if (sidebar.classList.contains('mobile-active')) {
                    toggleMobileMenu();
                }

                showToast('üìç', 'Click on canvas to place item');
            }

            function handleCanvasClick(e) {
                if (!placingItemType) return;

                // Use the tracked mouseX/mouseY which are updated by touchmove/mousemove
                const processed = getProcessedPoint(mouseX, mouseY);
                const x = processed.x;
                const y = processed.y;

                saveState();

                // Handle Templates
                if (placingItemType.startsWith('template_')) {
                    const roomKey = placingItemType.replace('template_', '');
                    const config = roomConfig[roomKey];
                    if (config) {
                        const newRoom = {
                            type: roomKey,
                            name: config.name,
                            length: config.defaultLength,
                            breadth: config.defaultBreadth,
                            width: config.defaultLength * SCALE,
                            height: config.defaultBreadth * SCALE,
                            color: config.color,
                            icon: config.icon,
                            x: x,
                            y: y
                        };
                        project.rooms.push(newRoom);
                    }
                } else {
                    // Handle regular symbols
                    addSymbol(placingItemType, x, y);
                }

                placingItemType = null;
                redrawAll();
                updateDimensionDisplay();
                updateLayerCounts();
            }

            // --- NEW: MOBILE MENU LOGIC ---
            function toggleMobileMenu() {
                const sidebar = document.getElementById('sidebarLeft');
                const overlay = document.getElementById('sidebarOverlay');
                sidebar.classList.toggle('mobile-active');
                overlay.classList.toggle('active');

                // Copy right sidebar content to left sidebar if on mobile for easy access
                if (window.innerWidth <= 992 && sidebar.classList.contains('mobile-active')) {
                    const rightSidebarContent = document.getElementById('sidebarRight').innerHTML;
                    document.getElementById('mobileProperties').innerHTML = rightSidebarContent;
                }
            }

            // Initialize
            function init() {
                window.addEventListener('resize', resizeCanvas);

                // NEW: Default 90 deg rotation for mobile
                if (window.innerWidth <= 992) {
                    rotation = 90;
                    const canvasEl = document.getElementById('designCanvas');
                    if (canvasEl) canvasEl.style.transform = `rotate(${rotation}deg)`;
                }

                resizeCanvas();

                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', handleMouseUp);

                // Touch events for mobile
                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        isPanning = true;
                        lastTouchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                        lastTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                        initialPinchDist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        initialPinchScale = SCALE;
                    } else if (e.touches.length === 1) {
                        isPanning = false;
                        handleMouseDown(e);
                    }
                    if (currentTool !== 'select' || placingRoom || e.touches.length > 1) e.preventDefault();
                }, { passive: false });

                canvas.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2 && isPanning) {
                        const currentTouchX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                        const currentTouchY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

                        offsetX += currentTouchX - lastTouchX;
                        offsetY += currentTouchY - lastTouchY;

                        lastTouchX = currentTouchX;
                        lastTouchY = currentTouchY;

                        // Pinch to zoom
                        const currentPinchDist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );

                        if (initialPinchDist > 0) {
                            const ratio = currentPinchDist / initialPinchDist;
                            let newScale = Math.round(initialPinchScale * ratio);
                            newScale = Math.max(5, Math.min(30, newScale));

                            if (newScale !== SCALE) {
                                document.getElementById('zoomRange').value = newScale;
                                updateScale();
                            }
                        }

                        redrawAll();
                    } else if (e.touches.length === 1 && !isPanning) {
                        handleMouseMove(e);
                    }
                    if (currentTool !== 'select' || placingRoom || e.touches.length > 1) e.preventDefault();
                }, { passive: false });

                canvas.addEventListener('click', (e) => {
                    if (placingItemType) handleCanvasClick(e);
                });

                canvas.addEventListener('touchend', (e) => {
                    if (e.touches.length < 2) isPanning = false;
                    handleMouseUp(e);
                }, { passive: false });

                canvas.addEventListener('dragover', (e) => e.preventDefault());
                canvas.addEventListener('drop', handleDrop);

                window.addEventListener('keydown', handleKeyDown);

                // Link the initial floor
                switchFloor(0);

                updateDimensionDisplay();
                updateLayerCounts();
            }

            function resizeCanvas() {
                const wrapper = document.querySelector('.canvas-wrapper');
                const oldWidth = canvas.width;
                const oldHeight = canvas.height;

                canvas.width = wrapper.clientWidth - 20;
                canvas.height = wrapper.clientHeight - 20;

                if (project.homeWall) {
                    // Re-center home wall
                    const wallWidth = project.totalLength * SCALE;
                    const wallHeight = project.totalBreadth * SCALE;

                    const oldX = project.homeWall.x;
                    const oldY = project.homeWall.y;

                    project.homeWall.x = (canvas.width - wallWidth) / 2;
                    project.homeWall.y = (canvas.height - wallHeight) / 2;

                    const dx = project.homeWall.x - oldX;
                    const dy = project.homeWall.y - oldY;

                    // Shift all assets to maintain relative position
                    project.rooms.forEach(room => {
                        room.x += dx;
                        room.y += dy;
                    });

                    elements.forEach(el => {
                        if (el.x1 !== undefined) {
                            el.x1 += dx; el.y1 += dy;
                            el.x2 += dx; el.y2 += dy;
                        } else {
                            el.x += dx; el.y += dy;
                        }
                    });
                }
                redrawAll();
            }

            // --- UNDO / REDO LOGIC ---

            function saveState() {
                const state = JSON.stringify({
                    elements: elements,
                    rooms: project.rooms
                });
                undoStack.push(state);
                if (undoStack.length > 50) undoStack.shift(); // Limit history
                redoStack = []; // Clear redo on new action
            }

            function undo() {
                if (undoStack.length === 0) {
                    showToast('‚ÑπÔ∏è', 'Nothing to undo');
                    return;
                }
                const currentState = JSON.stringify({
                    elements: elements,
                    rooms: project.rooms
                });
                redoStack.push(currentState);

                const prevState = JSON.parse(undoStack.pop());
                const activeFloor = project.floors[project.activeFloorIndex];
                activeFloor.elements = prevState.elements;
                activeFloor.rooms = prevState.rooms;
                elements = activeFloor.elements;
                project.rooms = activeFloor.rooms;
                project.homeWall = activeFloor.homeWall;

                redrawAll();
                updateLayerCounts();
                updateDimensionDisplay();
                showToast('‚Ü∂', 'Undo successful');
            }

            function redo() {
                if (redoStack.length === 0) {
                    showToast('‚ÑπÔ∏è', 'Nothing to redo');
                    return;
                }
                const currentState = JSON.stringify({
                    elements: elements,
                    rooms: project.rooms
                });
                undoStack.push(currentState);

                const nextState = JSON.parse(redoStack.pop());
                const activeFloor = project.floors[project.activeFloorIndex];
                activeFloor.elements = nextState.elements;
                activeFloor.rooms = nextState.rooms;
                elements = activeFloor.elements;
                project.rooms = activeFloor.rooms;
                project.homeWall = activeFloor.homeWall;

                redrawAll();
                updateLayerCounts();
                updateDimensionDisplay();
                showToast('‚Ü∑', 'Redo successful');
            }

            function handleKeyDown(e) {
                // Ctrl + Z
                if (e.ctrlKey && e.key.toLowerCase() === 'z') {
                    e.preventDefault();
                    undo();
                }
                // Ctrl + Y
                if (e.ctrlKey && e.key.toLowerCase() === 'y') {
                    e.preventDefault();
                    redo();
                }

                // Delete selected element
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (selectedElement) {
                        saveState();
                        elements = elements.filter(el => el !== selectedElement);
                        selectedElement = null;
                        updateLayerCounts();
                        redrawAll();
                        showToast('üóëÔ∏è', 'Element deleted');
                    } else if (selectedRoom) {
                        saveState();
                        project.rooms = project.rooms.filter(r => r !== selectedRoom);
                        selectedRoom = null;
                        updateLayerCounts();
                        redrawAll();
                        showToast('üóëÔ∏è', 'Room deleted');
                    }
                }
            }

            // Project Modal Functions
            function openProjectModal() {
                if (project.homeWall) {
                    if (confirm('Are you sure you want to reset the current design? All your rooms and drawn elements will be cleared.')) {
                        performProjectReset();
                    }
                    return;
                }
                document.getElementById('projectModal').classList.add('active');
            }

            function performProjectReset() {
                elements = [];
                project.rooms = [];
                offsetX = 0;
                offsetY = 0;
                undoStack = [];
                redoStack = [];

                drawHomeWall();
                updateDimensionDisplay();
                updateLayerCounts();
                showToast('‚úì', 'Design cleared successfully');
            }

            function closeProjectModal() {
                document.getElementById('projectModal').classList.remove('active');
            }

            function createProject() {
                const name = document.getElementById('projectNameInput').value;
                const type = document.getElementById('homeType').value;
                const length = parseInt(document.getElementById('homeLength').value);
                const breadth = parseInt(document.getElementById('homeBreadth').value);

                if (!name || !length || !breadth) {
                    alert('Please fill all fields');
                    return;
                }

                // Sync wall thickness
                const wallThick = document.getElementById('projectWallThickness').value;
                document.getElementById('wallThickness').value = wallThick;

                project.name = name;
                project.type = type;
                project.totalLength = length;
                project.totalBreadth = breadth;

                // Initialize/Reset floors
                project.floors = [{
                    id: 'floor_0',
                    name: 'Ground Floor',
                    elevation: 0,
                    height: 10,
                    length: length,
                    breadth: breadth,
                    elements: [],
                    rooms: [],
                    homeWall: null
                }];
                project.activeFloorIndex = 0;
                elements = project.floors[0].elements;
                project.rooms = project.floors[0].rooms;

                offsetX = 0;
                offsetY = 0;
                undoStack = [];
                redoStack = [];

                // Draw home boundary wall
                drawHomeWall();

                // CONVERT Boundary to Erasable Wall Elements
                if (project.homeWall) {
                    const { x, y, width, height } = project.homeWall;
                    const boundaryColor = '#1e293b';
                    const boundaryThick = 0.5; // feet

                    // Update active floor's homewall
                    project.floors[0].homeWall = project.homeWall;

                    // Add 4 boundary walls to elements
                    elements.push({ type: 'wall', x1: x, y1: y, x2: x + width, y2: y, color: boundaryColor, thickness: boundaryThick, isBoundary: true, alignment: 'outside' }); // North
                    elements.push({ type: 'wall', x1: x, y1: y + height, x2: x + width, y2: y + height, color: boundaryColor, thickness: boundaryThick, isBoundary: true, alignment: 'outside' }); // South
                    elements.push({ type: 'wall', x1: x, y1: y, x2: x, y2: y + height, color: boundaryColor, thickness: boundaryThick, isBoundary: true, alignment: 'outside' }); // West
                    elements.push({ type: 'wall', x1: x + width, y1: y, x2: x + width, y2: y + height, color: boundaryColor, thickness: boundaryThick, isBoundary: true, alignment: 'outside' }); // East
                }



                // Hide welcome screen
                document.getElementById('welcomeScreen').style.display = 'none';

                // Update displays
                updateFloorUI();
                updateDimensionDisplay();
                updateLayerCounts();

                closeProjectModal();

                showToast('‚úì', 'Project reset! Now select rooms or use drawing tools.');
            }

            function drawHomeWall() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (showGrid) drawGrid();

                const wallWidth = project.totalLength * SCALE;
                const wallHeight = project.totalBreadth * SCALE;

                // Center the wall on canvas
                const x = (canvas.width - wallWidth) / 2;
                const y = (canvas.height - wallHeight) / 2;

                project.homeWall = { x, y, width: wallWidth, height: wallHeight };

                // Draw background
                ctx.fillStyle = '#f9fafb';
                ctx.fillRect(x, y, wallWidth, wallHeight);

                // Draw wall border (thick outer walls)
                ctx.strokeStyle = '#1e293b';
                ctx.lineWidth = 10;
                ctx.strokeRect(x, y, wallWidth, wallHeight);

                // Title and dimensions text removed by user request
            }

            function drawGrid() {
                ctx.save();
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 0.5;

                // Determine Grid Origin
                let originX = 0;
                let originY = 0;

                if (project.homeWall) {
                    originX = project.homeWall.x;
                    originY = project.homeWall.y;
                }

                // Draw Lines (Aligned to Origin)
                const startX = Math.floor((-offsetX - originX) / gridSnap) * gridSnap + originX;
                const endX = -offsetX + canvas.width;
                const startY = Math.floor((-offsetY - originY) / gridSnap) * gridSnap + originY;
                const endY = -offsetY + canvas.height;

                // Draw vertical lines
                for (let x = startX; x <= endX; x += gridSnap) {
                    ctx.beginPath();
                    ctx.moveTo(x, -offsetY);
                    ctx.lineTo(x, -offsetY + canvas.height);
                    ctx.stroke();
                }

                // Draw horizontal lines
                for (let y = startY; y <= endY; y += gridSnap) {
                    ctx.beginPath();
                    ctx.moveTo(-offsetX, y);
                    ctx.lineTo(-offsetX + canvas.width, y);
                    ctx.stroke();
                }

                // Draw numbers if enabled AND project exists
                if (showGridNumbers && project.homeWall) {
                    const stepFt = gridSnap / SCALE;

                    ctx.font = `bold ${Math.max(10, gridSnap / 3.5)}px DM Sans`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Ruler Tracks (Fixed to Viewport)
                    const rulerTop = -offsetY;
                    const rulerLeft = -offsetX;

                    // Draw Ruler Backgrounds
                    ctx.fillStyle = 'rgba(248, 250, 252, 0.9)'; // Light background
                    ctx.fillRect(rulerLeft, rulerTop, canvas.width, 24); // Top strip
                    ctx.fillRect(rulerLeft, rulerTop, 24, canvas.height); // Left strip

                    // Border for rulers
                    ctx.strokeStyle = '#cbd5e1';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(rulerLeft, rulerTop + 24);
                    ctx.lineTo(rulerLeft + canvas.width, rulerTop + 24);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(rulerLeft + 24, rulerTop);
                    ctx.lineTo(rulerLeft + 24, rulerTop + canvas.height);
                    ctx.stroke();

                    ctx.fillStyle = '#475569'; // Text color

                    // --- Top Ruler (X-Axis) ---
                    // Loop only through project dimensions (0 to totalLength)
                    for (let f = 0; f <= project.totalLength; f += stepFt) {
                        const x = originX + (f * SCALE);

                        // Optimization: Only draw if visible in viewport X
                        if (x < -offsetX - 20 || x > -offsetX + canvas.width + 20) continue;

                        ctx.fillText(f.toString(), x, rulerTop + 12);

                        // Tick
                        ctx.beginPath();
                        ctx.moveTo(x, rulerTop + 20);
                        ctx.lineTo(x, rulerTop + 24);
                        ctx.strokeStyle = '#94a3b8';
                        ctx.stroke();
                    }

                    // --- Left Ruler (Y-Axis) ---
                    for (let f = 0; f <= project.totalBreadth; f += stepFt) {
                        const y = originY + (f * SCALE);

                        // Optimization: Only draw if visible in viewport Y
                        if (y < -offsetY - 20 || y > -offsetY + canvas.height + 20) continue;

                        ctx.fillText(f.toString(), rulerLeft + 12, y);

                        // Tick
                        ctx.beginPath();
                        ctx.moveTo(rulerLeft + 20, y);
                        ctx.lineTo(rulerLeft + 24, y);
                        ctx.strokeStyle = '#94a3b8';
                        ctx.stroke();
                    }

                    // Draw "0,0" corner block
                    ctx.fillStyle = '#f1f5f9';
                    ctx.fillRect(rulerLeft, rulerTop, 24, 24);
                    ctx.strokeRect(rulerLeft, rulerTop, 24, 24);
                    ctx.fillStyle = '#3b82f6';
                    ctx.font = 'bold 10px DM Sans';
                    ctx.fillText('ft', rulerLeft + 12, rulerTop + 12);
                }
                ctx.restore();
            }

            function toggleGridNumbers() {
                showGridNumbers = !showGridNumbers;
                const btn = document.getElementById('gridNumberToggle');
                if (showGridNumbers) {
                    btn.style.background = 'var(--primary)';
                    btn.style.color = 'white';
                } else {
                    btn.style.background = '';
                    btn.style.color = '';
                }
                redrawAll();
            }

            function toggleMeasurements() {
                showMeasurements = !showMeasurements;
                const btn = document.getElementById('measurementToggleBtn');
                if (showMeasurements) {
                    btn.classList.add('active');
                    showToast('üìè', 'Measurements: ON');
                } else {
                    btn.classList.remove('active');
                    showToast('üìè', 'Measurements: OFF');
                }
                redrawAll();
            }


            // Tool Selection
            function selectTool(tool) {
                currentTool = tool;
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(`tool-${tool}`).classList.add('active');

                if (tool === 'select') {
                    canvas.style.cursor = 'default';
                    document.getElementById('eraserSettings').style.display = 'none';
                } else if (tool === 'eraser') {
                    updateEraserCursor();
                    document.getElementById('eraserSettings').style.display = 'block';
                } else {
                    canvas.style.cursor = 'crosshair';
                    document.getElementById('eraserSettings').style.display = 'none';
                }

                // Close mobile menu if open
                if (document.getElementById('sidebarLeft').classList.contains('mobile-active')) toggleMobileMenu();
            }

            // Canvas Event Handlers
            // Canvas Event Handlers
            function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                let isTouch = false;

                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                    isTouch = true;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                    isTouch = true;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                // Normalize coordinates based on visual scale vs internal size
                let x = clientX - rect.left;
                let y = clientY - rect.top;

                // Handle rotation mapping back to logical canvas coordinates
                let logicalX, logicalY;
                const sX = canvas.width / (rotation % 180 === 0 ? rect.width : rect.height);
                const sY = canvas.height / (rotation % 180 === 0 ? rect.height : rect.width);

                if (rotation === 0) {
                    logicalX = x * sX;
                    logicalY = y * sY;
                } else if (rotation === 90) {
                    logicalX = y * sX;
                    logicalY = (rect.width - x) * sY;
                } else if (rotation === 180) {
                    logicalX = (rect.width - x) * sX;
                    logicalY = (rect.height - y) * sY;
                } else if (rotation === 270) {
                    logicalX = (rect.height - y) * sX;
                    logicalY = x * sY;
                } else {
                    logicalX = x * sX;
                    logicalY = y * sY;
                }

                // Subtract panning offset AFTER rotation mapping
                return {
                    x: logicalX - offsetX,
                    y: logicalY - offsetY
                };
            }

            function handleMouseDown(e) {
                if (placingItemType || !currentTool) return;

                const pos = getMousePos(e);
                const processedStart = getProcessedPoint(pos.x, pos.y);
                startX = processedStart.x;
                startY = processedStart.y;

                if (currentTool === 'eraser') {
                    saveState();
                    isDrawing = true;
                    eraseAt(pos.x, pos.y);
                    return;
                }

                if (currentTool === 'select') {
                    // Check for resize handle first
                    if (selectedRoom) {
                        const handleX = selectedRoom.x + selectedRoom.width;
                        const handleY = selectedRoom.y + selectedRoom.height;
                        if (Math.abs(pos.x - handleX) < 15 && Math.abs(pos.y - handleY) < 15) {
                            isResizing = true;
                            canvas.style.cursor = 'nwse-resize';
                            saveState();
                            return;
                        }
                    } else if (selectedElement?.type === 'symbol') {
                        const config = symbols[selectedElement.symbolType];
                        if (config?.isStair) {
                            const s = SCALE * (selectedElement.scale || 1);
                            const w = (selectedElement.width || config.width) * s;
                            const l = (selectedElement.length || config.length) * s;
                            // Calculate handle position relative to element's center (x,y)
                            const handleX = selectedElement.x + w / 2;
                            const handleY = selectedElement.y + l / 2;
                            if (Math.abs(pos.x - handleX) < 15 && Math.abs(pos.y - handleY) < 15) {
                                isResizing = true;
                                canvas.style.cursor = 'nwse-resize';
                                saveState();
                                return;
                            }
                        }
                    }

                    const target = findTarget(pos.x, pos.y);
                    if (target) {
                        if (target.type === 'room') {
                            selectedRoom = target.data;
                            selectedElement = null;
                            dragOffsetX = pos.x - selectedRoom.x;
                            dragOffsetY = pos.y - selectedRoom.y;
                        } else {
                            selectedElement = target.data;
                            selectedRoom = null;
                            if (selectedElement.type === 'text' || selectedElement.type === 'symbol') {
                                dragOffsetX = pos.x - selectedElement.x;
                                dragOffsetY = pos.y - selectedElement.y;
                            } else {
                                dragOffsetX = pos.x - selectedElement.x1;
                                dragOffsetY = pos.y - selectedElement.y1;
                            }
                        }
                        isMovingElement = true;
                        canvas.style.cursor = 'grabbing';
                        saveState();
                    } else {
                        selectedElement = null;
                        selectedRoom = null;
                    }
                    updateSelectionUI();
                    redrawAll();
                    return;
                }
                isDrawing = true;

                if (currentTool === 'text') {
                    addText(startX, startY);
                    isDrawing = false;
                }
            }

            function findTarget(x, y) {
                const isMobile = window.innerWidth <= 992;

                // Check elements FIRST (makes painting walls easier)
                for (let i = elements.length - 1; i >= 0; i--) {
                    const el = elements[i];
                    if (el.type === 'text' || el.type === 'symbol') {
                        const config = symbols[el.symbolType];
                        const dx = x - el.x;
                        const dy = y - el.y;
                        const rad = ((el.rotation || 0) * Math.PI) / 180;
                        const localX = dx * Math.cos(-rad) - dy * Math.sin(-rad);
                        const localY = dx * Math.sin(-rad) + dy * Math.cos(-rad);

                        let w = 40, h = 40;
                        if (config) {
                            const s = SCALE;
                            if (config.isStair) {
                                w = (el.width || config.width) * s * (el.scale || 1);
                                h = (el.length || config.length) * s * (el.scale || 1);
                                if (config.stairType === 'spiral') {
                                    w = (el.radius || config.radius) * 2 * s * (el.scale || 1);
                                    h = w;
                                } else if (config.stairType === 'lshape') {
                                    w = Math.max(w, (el.breadth || config.breadth) * s * (el.scale || 1));
                                    h = Math.max(h, (el.length || config.length) * s * (el.scale || 1));
                                }
                            } else {
                                w = config.width * (el.scale || 1);
                                h = config.height * (el.scale || 1);
                            }
                        }
                        if (Math.abs(localX) < (w / 2) + 10 && Math.abs(localY) < (h / 2) + 10) {
                            return { type: 'element', data: el };
                        }
                    } else {
                        const tolerance = isMobile ? 20 : 10;
                        if (isPointNearLine(x, y, el.x1, el.y1, el.x2, el.y2, tolerance)) {
                            return { type: 'element', data: el };
                        }
                    }
                }

                // Check rooms SECOND (if room mode is on)
                if (showRoomMode) {
                    for (let i = project.rooms.length - 1; i >= 0; i--) {
                        const r = project.rooms[i];
                        if (x >= r.x && x <= r.x + r.width && y >= r.y && y <= r.y + r.height) {
                            return { type: 'room', data: r };
                        }
                    }
                }
                return null;
            }

            function isPointNearLine(px, py, x1, y1, x2, y2, tolerance) {
                const l2 = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);
                if (l2 === 0) return Math.sqrt(Math.pow(px - x1, 2) + Math.pow(py - y1, 2)) < tolerance;
                let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
                t = Math.max(0, Math.min(1, t));
                const dist = Math.sqrt(Math.pow(px - (x1 + t * (x2 - x1)), 2) + Math.pow(py - (y1 + t * (y2 - y1)), 2));
                return dist < tolerance;
            }

            // Selection Actions
            function updateSelectionUI() {
                const panel = document.getElementById('selectionProperties');
                const typeName = document.getElementById('selectedTypeName');
                const typeIcon = document.getElementById('selectedTypeIcon');
                const doorCtrls = document.querySelectorAll('.door-ctrl');
                const wallHeightCtrl = document.getElementById('wallHeightCtrl');
                const scaleCtrls = document.getElementById('scaleCtrls');

                if (selectedElement || selectedRoom) {
                    panel.style.display = 'block';

                    if (selectedRoom) {
                        typeName.textContent = 'Room: ' + selectedRoom.name;
                        typeIcon.textContent = selectedRoom.icon || 'üè†';
                    } else {
                        typeName.textContent = selectedElement.type.charAt(0).toUpperCase() + selectedElement.type.slice(1);
                        const icons = { wall: 'üìè', door: 'üö™', window: 'ü™ü', symbol: 'ü™ë', text: 'üìù' };
                        typeIcon.textContent = icons[selectedElement.type] || '‚öôÔ∏è';
                    }

                    doorCtrls.forEach(c => c.style.display = (selectedElement?.type === 'door') ? 'block' : 'none');
                    if (wallHeightCtrl) {
                        wallHeightCtrl.style.display = (selectedElement?.type === 'wall') ? 'block' : 'none';
                        if (selectedElement?.type === 'wall') {
                            document.getElementById('selectedWallHeight').value = selectedElement.height || '';
                        }
                    }

                    const isWall = selectedElement?.type === 'wall';
                    const isColorable = selectedElement && (isWall || selectedElement.type === 'door' || selectedElement.type === 'window' || selectedElement.type === 'text');

                    document.getElementById('selectionColorRow').style.display = isColorable ? 'block' : 'none';

                    if (isColorable) {
                        if (isWall) {
                            document.getElementById('singleColorCtrl').style.display = 'none';
                            document.getElementById('dualColorCtrl').style.display = 'flex';
                            document.getElementById('selectionTextureCtrl').style.display = 'block';
                            document.getElementById('innerColorPicker').value = selectedElement.color || '#475569';
                            document.getElementById('outerColorPicker').value = selectedElement.color2 || selectedElement.color || '#475569';
                            document.getElementById('selectionTexture').value = selectedElement.texture || '';
                        } else {
                            document.getElementById('singleColorCtrl').style.display = 'block';
                            document.getElementById('dualColorCtrl').style.display = 'none';
                            document.getElementById('selectionTextureCtrl').style.display = 'none';
                            document.getElementById('selectionColorPicker').value = selectedElement.color || (selectedElement.type === 'text' ? '#000000' : '#475569');
                            document.getElementById('colorLabel').textContent = selectedElement.type === 'text' ? 'Text Color' : 'Paint Color';
                        }
                    }

                    const isScalable = selectedElement?.type === 'symbol' || selectedRoom;
                    scaleCtrls.style.display = isScalable ? 'block' : 'none';
                } else {
                    panel.style.display = 'none';
                }
            }

            function updateSelectedWallHeight(val) {
                if (!selectedElement || selectedElement.type !== 'wall') return;
                saveState();
                if (val && val > 0) {
                    selectedElement.height = parseFloat(val);
                } else {
                    delete selectedElement.height;
                }
                if (is3DMode) init3D(); // Refresh 3D if active
                showToast('üìè', 'Wall height updated');
            }

            function changeSelectedColor(type) {
                if (!selectedElement) return;
                saveState();

                if (type === 'single') {
                    selectedElement.color = document.getElementById('selectionColorPicker').value;
                } else if (type === 'inner') {
                    selectedElement.color = document.getElementById('innerColorPicker').value;
                } else if (type === 'outer') {
                    selectedElement.color2 = document.getElementById('outerColorPicker').value;
                }

                redrawAll();
                if (is3DMode) init3D(); // Live update 3D view
                showToast('üé®', 'Color updated');
            }

            function rotateSelected() {
                if (!selectedElement && !selectedRoom) return;
                saveState();

                if (selectedRoom) {
                    const temp = selectedRoom.length;
                    selectedRoom.length = selectedRoom.breadth;
                    selectedRoom.breadth = temp;
                    selectedRoom.width = selectedRoom.length * SCALE;
                    selectedRoom.height = selectedRoom.breadth * SCALE;
                } else if (selectedElement) {
                    if (selectedElement.type === 'text' || selectedElement.type === 'symbol') {
                        selectedElement.rotation = (selectedElement.rotation || 0) + 90;
                        if (selectedElement.rotation >= 360) selectedElement.rotation = 0;
                    } else {
                        // Rotate line around its center
                        const midX = (selectedElement.x1 + selectedElement.x2) / 2;
                        const midY = (selectedElement.y1 + selectedElement.y2) / 2;
                        const x1 = selectedElement.x1 - midX;
                        const y1 = selectedElement.y1 - midY;
                        const x2 = selectedElement.x2 - midX;
                        const y2 = selectedElement.y2 - midY;

                        selectedElement.x1 = snapToGrid(midX - y1);
                        selectedElement.y1 = snapToGrid(midY + x1);
                        selectedElement.x2 = snapToGrid(midX - y2);
                        selectedElement.y2 = snapToGrid(midY + x2);
                    }
                }
                redrawAll();
                updateDimensionDisplay();
                showToast('üîÑ', 'Rotated selection');
            }

            function resizeSelected(factor) {
                if (!selectedElement && !selectedRoom) return;
                saveState();

                if (selectedRoom) {
                    selectedRoom.length = Math.round(selectedRoom.length * factor * 2) / 2;
                    selectedRoom.breadth = Math.round(selectedRoom.breadth * factor * 2) / 2;
                    selectedRoom.width = selectedRoom.length * SCALE;
                    selectedRoom.height = selectedRoom.breadth * SCALE;
                } else if (selectedElement?.type === 'symbol') {
                    selectedElement.scale = (selectedElement.scale || 1) * factor;
                    // Scale internal dimensional properties together
                    if (selectedElement.width) selectedElement.width *= factor;
                    if (selectedElement.length) selectedElement.length *= factor;
                    if (selectedElement.breadth) selectedElement.breadth *= factor;
                    if (selectedElement.radius) selectedElement.radius *= factor;

                    // Update step count for stairs based on new scale
                    const config = symbols[selectedElement.symbolType];
                    if (config?.isStair && selectedElement.steps) {
                        if (config.stairType === 'straight') selectedElement.steps = Math.round(selectedElement.length);
                        else if (config.stairType === 'lshape') selectedElement.steps = Math.round(selectedElement.length + selectedElement.breadth);
                    }
                }
                redrawAll();
                updateDimensionDisplay();
                showToast('üìè', 'Resized proportionally');
            }

            function adjustDimension(dim, delta) {
                if (!selectedElement && !selectedRoom) return;
                saveState();

                if (selectedRoom) {
                    if (dim === 'width') selectedRoom.length = Math.max(2, selectedRoom.length + delta);
                    if (dim === 'length') selectedRoom.breadth = Math.max(2, selectedRoom.breadth + delta);
                    selectedRoom.width = selectedRoom.length * SCALE;
                    selectedRoom.height = selectedRoom.breadth * SCALE;
                } else if (selectedElement?.type === 'symbol') {
                    const config = symbols[selectedElement.symbolType];
                    if (dim === 'width') {
                        if (selectedElement.width !== undefined) selectedElement.width = Math.max(1, selectedElement.width + delta);
                        else if (selectedElement.breadth !== undefined) selectedElement.breadth = Math.max(1, selectedElement.breadth + delta);
                        else if (selectedElement.radius !== undefined) selectedElement.radius = Math.max(1, selectedElement.radius + delta * 0.5);
                    } else if (dim === 'length') {
                        if (selectedElement.length !== undefined) selectedElement.length = Math.max(1, selectedElement.length + delta);
                        else if (selectedElement.radius !== undefined) selectedElement.radius = Math.max(1, selectedElement.radius + delta * 0.5);
                    }

                    // Link steps to dimensions for stairs
                    if (config?.isStair) {
                        if (config.stairType === 'straight') {
                            selectedElement.steps = Math.round(selectedElement.length || config.length);
                        } else if (config.stairType === 'lshape') {
                            selectedElement.steps = Math.round((selectedElement.length || config.length) + (selectedElement.breadth || config.breadth));
                        }
                    }
                }
                redrawAll();
                updateDimensionDisplay();
                showToast('üìè', `Adjusted ${dim}`);
            }

            function flipDoorHinge() {
                if (selectedElement?.type !== 'door') return;
                saveState();
                selectedElement.flippedHinge = !selectedElement.flippedHinge;
                redrawAll();
                showToast('‚áÑ', 'Hinge flipped');
            }

            function flipDoorSwing() {
                if (selectedElement?.type !== 'door') return;
                saveState();
                selectedElement.flippedSwing = !selectedElement.flippedSwing;
                redrawAll();
                showToast('‚áÖ', 'Swing flipped');
            }

            function deleteSelected() {
                if (selectedElement) {
                    saveState();
                    elements = elements.filter(el => el !== selectedElement);
                    selectedElement = null;
                } else if (selectedRoom) {
                    saveState();
                    project.rooms = project.rooms.filter(r => r !== selectedRoom);
                    selectedRoom = null;
                }
                updateSelectionUI();
                updateLayerCounts();
                redrawAll();
                showToast('üóëÔ∏è', 'Deleted');
            }

            function isPointNearLine(px, py, x1, y1, x2, y2, tolerance) {
                const l2 = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);
                if (l2 === 0) return Math.sqrt(Math.pow(px - x1, 2) + Math.pow(py - y1, 2)) < tolerance;
                let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
                t = Math.max(0, Math.min(1, t));
                const dist = Math.sqrt(Math.pow(px - (x1 + t * (x2 - x1)), 2) + Math.pow(py - (y1 + t * (y2 - y1)), 2));
                return dist < tolerance;
            }

            function handleMouseMove(e) {
                const pos = getMousePos(e);
                const currentX = pos.x;
                const currentY = pos.y;

                // track for preview
                mouseX = currentX;
                mouseY = currentY;

                if (currentTool === 'eraser' && isDrawing) {
                    eraseAt(pos.x, pos.y);
                    return;
                }

                if (placingItemType) {
                    redrawAll();
                    return;
                }

                if (isResizing) {
                    canvas.style.cursor = 'nwse-resize';
                    if (selectedRoom) {
                        const newW = Math.max(2, (currentX - selectedRoom.x) / SCALE);
                        const newH = Math.max(2, (currentY - selectedRoom.y) / SCALE);
                        selectedRoom.length = Math.round(newW * 2) / 2;
                        selectedRoom.breadth = Math.round(newH * 2) / 2;
                        selectedRoom.width = selectedRoom.length * SCALE;
                        selectedRoom.height = selectedRoom.breadth * SCALE;
                    } else if (selectedElement?.type === 'symbol') {
                        const config = symbols[selectedElement.symbolType];
                        const s = SCALE;
                        if (config?.isStair) {
                            if (config.stairType === 'spiral') {
                                const dist = Math.sqrt(Math.pow(currentX - selectedElement.x, 2) + Math.pow(currentY - selectedElement.y, 2));
                                selectedElement.radius = Math.max(1, (dist / s));
                            } else {
                                const newW = Math.max(2, (currentX - selectedElement.x) * 2 / s);
                                const newL = Math.max(2, (currentY - selectedElement.y) * 2 / s);
                                if (config.stairType === 'straight') {
                                    selectedElement.width = Math.round(newW * 2) / 2;
                                    selectedElement.length = Math.round(newL * 2) / 2;
                                    selectedElement.steps = Math.round(selectedElement.length);
                                } else if (config.stairType === 'lshape') {
                                    selectedElement.length = Math.round(newL * 2) / 2;
                                    selectedElement.breadth = Math.round(newW * 2) / 2;
                                    selectedElement.steps = Math.round(selectedElement.length + selectedElement.breadth);
                                }
                            }
                        }
                    }
                    redrawAll();
                    return;
                }

                if (isMovingElement) {
                    canvas.style.cursor = 'grabbing';
                    if (selectedRoom) {
                        let nextX = snapToGrid(currentX - dragOffsetX);
                        let nextY = snapToGrid(currentY - dragOffsetY);
                        const snapDist = 15;
                        if (project.homeWall) {
                            const hx1 = project.homeWall.x, hy1 = project.homeWall.y;
                            const hx2 = project.homeWall.x + project.homeWall.width, hy2 = project.homeWall.y + project.homeWall.height;
                            if (Math.abs(nextX - hx1) < snapDist) nextX = hx1;
                            if (Math.abs((nextX + selectedRoom.width) - hx2) < snapDist) nextX = hx2 - selectedRoom.width;
                            if (Math.abs(nextY - hy1) < snapDist) nextY = hy1;
                            if (Math.abs((nextY + selectedRoom.height) - hy2) < snapDist) nextY = hy2 - selectedRoom.height;
                        }
                        project.rooms.forEach(other => {
                            if (other === selectedRoom) return;
                            if (Math.abs(nextX - other.x) < snapDist) nextX = other.x;
                            if (Math.abs(nextX - (other.x + other.width)) < snapDist) nextX = other.x + other.width;
                            if (Math.abs((nextX + selectedRoom.width) - other.x) < snapDist) nextX = other.x - selectedRoom.width;
                            if (Math.abs((nextX + selectedRoom.width) - (other.x + other.width)) < snapDist) nextX = other.x + other.width - selectedRoom.width;
                            if (Math.abs(nextY - other.y) < snapDist) nextY = other.y;
                            if (Math.abs(nextY - (other.y + other.height)) < snapDist) nextY = other.y + other.height;
                            if (Math.abs((nextY + selectedRoom.height) - other.y) < snapDist) nextY = other.y - selectedRoom.height;
                            if (Math.abs((nextY + selectedRoom.height) - (other.y + other.height)) < snapDist) nextY = other.y + other.height - selectedRoom.height;
                        });
                        selectedRoom.x = nextX;
                        selectedRoom.y = nextY;
                    } else if (selectedElement) {
                        if (selectedElement.type === 'text' || selectedElement.type === 'symbol') {
                            selectedElement.x = snapToGrid(currentX - dragOffsetX);
                            selectedElement.y = snapToGrid(currentY - dragOffsetY);
                        } else {
                            const dx = snapToGrid(currentX - dragOffsetX) - selectedElement.x1;
                            const dy = snapToGrid(currentY - dragOffsetY) - selectedElement.y1;
                            selectedElement.x1 += dx;
                            selectedElement.y1 += dy;
                            selectedElement.x2 += dx;
                            selectedElement.y2 += dy;
                        }
                    }
                    redrawAll();
                    return;
                }

                if (currentTool === 'select') {
                    const target = findTarget(pos.x, pos.y);
                    let onHandle = false;
                    if (selectedRoom) {
                        if (Math.abs(pos.x - (selectedRoom.x + selectedRoom.width)) < 15 && Math.abs(pos.y - (selectedRoom.y + selectedRoom.height)) < 15) onHandle = true;
                    } else if (selectedElement?.type === 'symbol') {
                        const config = symbols[selectedElement.symbolType];
                        if (config?.isStair) {
                            const s = SCALE;
                            if (Math.abs(pos.x - (selectedElement.x + (selectedElement.width || config.width) * s / 2)) < 15 && Math.abs(pos.y - (selectedElement.y + (selectedElement.length || config.length) * s / 2)) < 15) onHandle = true;
                        }
                    }
                    if (onHandle) canvas.style.cursor = 'nwse-resize';
                    else canvas.style.cursor = target ? 'grab' : 'default';
                } else if (currentTool === 'eraser') {
                    canvas.style.cursor = 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' style=\'fill:black\'><circle cx=\'12\' cy=\'12\' r=\'10\' fill=\'white\' stroke=\'black\' stroke-width=\'2\' opacity=\'0.5\'/></svg>") 12 12, auto';
                } else {
                    canvas.style.cursor = 'crosshair';
                }

                if (isDrawing && !placingRoom) {
                    redrawAll();
                    const processedCurrent = getProcessedPoint(currentX, currentY);
                    drawPreview(startX, startY, processedCurrent.x, processedCurrent.y);
                }
            }

            function handleMouseUp(e) {
                if (isResizing) {
                    isResizing = false;
                    canvas.style.cursor = 'default';
                    redrawAll();
                    updateDimensionDisplay();
                    return;
                }
                if (isMovingElement) {
                    isMovingElement = false;
                    canvas.style.cursor = 'default';
                    redrawAll();
                    return;
                }

                if (!isDrawing || placingRoom) {
                    if (currentTool === 'select') canvas.style.cursor = 'default';
                    else canvas.style.cursor = 'crosshair';
                    return;
                }

                const pos = getMousePos(e);
                const processedEnd = getProcessedPoint(pos.x, pos.y);
                const endX = processedEnd.x;
                const endY = processedEnd.y;

                if (Math.abs(endX - startX) > 5 || Math.abs(endY - startY) > 5) {
                    saveState(); // Save state before change
                    addElement(currentTool, startX, startY, endX, endY);
                }

                isDrawing = false;
                redrawAll();
            }


            function handleDrop(e) {
                e.preventDefault();
                const symbolType = e.dataTransfer.getData('symbol');

                if (!symbolType) return;
                const pos = getMousePos(e);
                const processed = getProcessedPoint(pos.x, pos.y);
                const x = processed.x;
                const y = processed.y;

                saveState();

                // Handle Quick Templates generically
                if (symbolType.startsWith('template_')) {
                    const roomKey = symbolType.replace('template_', '');
                    const config = roomConfig[roomKey];

                    if (config) {
                        const newRoom = {
                            type: roomKey,
                            name: config.name,
                            length: config.defaultLength,
                            breadth: config.defaultBreadth,
                            width: config.defaultLength * SCALE,
                            height: config.defaultBreadth * SCALE,
                            color: config.color,
                            icon: config.icon,
                            x: x,
                            y: y
                        };
                        project.rooms.push(newRoom);
                        redrawAll();
                        updateDimensionDisplay();
                        updateLayerCounts();
                        showToast(config.icon, `${config.name} template placed`);
                        return;
                    }
                }

                if (!symbols[symbolType]) {
                    showToast('‚ùå', 'Invalid furniture/symbol');
                    return;
                }

                addSymbol(symbolType, x, y);
            }

            // Drawing Functions
            function updateEraserCursor() {
                if (currentTool !== 'eraser') return;
                const sizeFt = parseFloat(document.getElementById('eraserSize').value);
                document.getElementById('eraserSizeVal').textContent = sizeFt + 'ft';
                const r = sizeFt * SCALE;
                canvas.style.cursor = `url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='${r * 2}' height='${r * 2}'><circle cx='${r}' cy='${r}' r='${r - 1}' fill='white' stroke='black' stroke-width='2' opacity='0.5'/></svg>") ${r} ${r}, auto`;
            }

            function snapToGrid(value) {
                if (snapEnabled && gridSnap > 0) {
                    return Math.round(value / gridSnap) * gridSnap;
                }
                return value;
            }

            function eraseAt(ex, ey) {
                const sizeFt = parseFloat(document.getElementById('eraserSize').value) || 1;
                const radius = sizeFt * SCALE;
                let changed = false;
                const newElements = [];

                elements.forEach(el => {
                    const lineTypes = ['wall', 'door', 'window', 'dimension'];
                    if (lineTypes.includes(el.type)) {
                        // Line splitting logic
                        const dx = el.x2 - el.x1;
                        const dy = el.y2 - el.y1;
                        const d2 = dx * dx + dy * dy;
                        if (d2 < 1) { newElements.push(el); return; }

                        const t = ((ex - el.x1) * dx + (ey - el.y1) * dy) / d2;
                        const closestX = el.x1 + Math.max(0, Math.min(1, t)) * dx;
                        const closestY = el.y1 + Math.max(0, Math.min(1, t)) * dy;
                        const dist = Math.sqrt(Math.pow(ex - closestX, 2) + Math.pow(ey - closestY, 2));

                        if (dist < radius) {
                            changed = true;
                            const Qx = el.x1 - ex;
                            const Qy = el.y1 - ey;
                            const a = d2;
                            const b = 2 * (Qx * dx + Qy * dy);
                            const c = (Qx * Qx + Qy * Qy) - radius * radius;
                            const det = b * b - 4 * a * c;

                            if (det >= 0) {
                                const root = Math.sqrt(det);
                                const t1 = (-b - root) / (2 * a);
                                const t2 = (-b + root) / (2 * a);
                                const startT = Math.min(t1, t2);
                                const endT = Math.max(t1, t2);

                                if (startT > 0.01) {
                                    newElements.push({ ...el, x2: el.x1 + startT * dx, y2: el.y1 + startT * dy });
                                }
                                if (endT < 0.99) {
                                    newElements.push({ ...el, x1: el.x1 + endT * dx, y1: el.y1 + endT * dy });
                                }
                            }
                        } else {
                            newElements.push(el);
                        }
                    } else if (el.type === 'symbol' || el.type === 'text') {
                        const d = Math.sqrt(Math.pow(ex - el.x, 2) + Math.pow(ey - el.y, 2));
                        if (d < radius + 10) {
                            changed = true;
                        } else {
                            newElements.push(el);
                        }
                    } else {
                        newElements.push(el);
                    }
                });

                if (changed) {
                    project.floors[project.activeFloorIndex].elements = newElements;
                    elements = newElements;
                    updateLayerCounts();
                    redrawAll();
                }
            }

            function getProcessedPoint(rawX, rawY) {
                let x = snapToGrid(rawX);
                let y = snapToGrid(rawY);

                // Determine if the current action is wall-like (needs auto-join)
                const wallTools = ['wall', 'door', 'window', 'dimension'];
                const isWallLike = wallTools.includes(currentTool) || (placingItemType && placingItemType.startsWith('template_'));

                if (isWallLike) {
                    // Auto-join/snap to nearest endpoint or wall line (within 1 foot / SCALE pixels)
                    const snapDist = SCALE;
                    let bestSnap = { x: x, y: y, dist: snapDist + 1 };

                    const checkPoint = (px, py) => {
                        const d = Math.sqrt(Math.pow(x - px, 2) + Math.pow(y - py, 2));
                        if (d < bestSnap.dist) {
                            bestSnap = { x: px, y: py, dist: d };
                        }
                    };

                    const checkLine = (x1, y1, x2, y2) => {
                        const l2 = Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2);
                        if (l2 === 0) return;
                        let t = ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / l2;
                        t = Math.max(0, Math.min(1, t));
                        checkPoint(x1 + t * (x2 - x1), y1 + t * (y2 - y1));
                    };

                    // 1. Check Home Boundary Walls
                    if (project.homeWall) {
                        const h = project.homeWall;
                        checkLine(h.x, h.y, h.x + h.width, h.y); // North
                        checkLine(h.x, h.y + h.height, h.x + h.width, h.y + h.height); // South
                        checkLine(h.x, h.y, h.x, h.y + h.height); // West
                        checkLine(h.x + h.width, h.y, h.x + h.width, h.y + h.height); // East
                    }

                    // 2. Check Room walls
                    project.rooms.forEach(r => {
                        checkLine(r.x, r.y, r.x + r.width, r.y);
                        checkLine(r.x, r.y + r.height, r.x + r.width, r.y + r.height);
                        checkLine(r.x, r.y, r.x, r.y + r.height);
                        checkLine(r.x + r.width, r.y, r.x + r.width, r.y + r.height);
                    });

                    // 3. Check Manual Walls
                    elements.forEach(el => {
                        if (el.type === 'wall') {
                            checkLine(el.x1, el.y1, el.x2, el.y2);
                        }
                    });

                    if (bestSnap.dist <= snapDist) {
                        x = bestSnap.x;
                        y = bestSnap.y;
                    }
                }

                // Constrain to Home Wall Boundary - DISABLED to allow drawing outside
                // if (project.homeWall) {
                //     x = Math.max(project.homeWall.x, Math.min(project.homeWall.x + project.homeWall.width, x));
                //     y = Math.max(project.homeWall.y, Math.min(project.homeWall.y + project.homeWall.height, y));
                // }

                return { x, y };
            }

            function addElement(type, x1, y1, x2, y2) {
                // Check for duplicate walls (Manual or Template)
                if (type === 'wall') {
                    // 1. Check against existing manual walls
                    const isManualDuplicate = elements.some(el => {
                        if (el.type !== 'wall') return false;
                        const sameDir = (el.x1 === x1 && el.y1 === y1 && el.x2 === x2 && el.y2 === y2);
                        const oppDir = (el.x1 === x2 && el.y1 === y2 && el.x2 === x1 && el.y2 === y1);
                        return sameDir || oppDir;
                    });
                    if (isManualDuplicate) return;

                    // 2. Check against Room template edges
                    const isTemplateDuplicate = project.rooms.some(room => {
                        const rX1 = room.x, rY1 = room.y, rX2 = room.x + room.width, rY2 = room.y + room.height;
                        const edges = [
                            { x1: rX1, y1: rY1, x2: rX2, y2: rY1 }, // North
                            { x1: rX1, y1: rY2, x2: rX2, y2: rY2 }, // South
                            { x1: rX1, y1: rY1, x2: rX1, y2: rY2 }, // West
                            { x1: rX2, y1: rY1, x2: rX2, y2: rY2 }  // East
                        ];
                        return edges.some(edge => {
                            const sameDir = (edge.x1 === x1 && edge.y1 === y1 && edge.x2 === x2 && edge.y2 === y2);
                            const oppDir = (edge.x1 === x2 && edge.y1 === y2 && edge.x2 === x1 && edge.y2 === y1);
                            return sameDir || oppDir;
                        });
                    });
                    if (isTemplateDuplicate) return;
                }

                const element = {
                    type: type,
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                    color: document.getElementById('wallColor').value,
                    thickness: parseFloat(document.getElementById('wallThickness').value),
                    alignment: (type === 'wall' || type === 'door' || type === 'window') ? getSmartAlignment(x1, y1, x2, y2) : 'center'
                };

                function getSmartAlignment(x1, y1, x2, y2) {
                    const userAlignment = document.getElementById('wallAlignment').value;

                    // If no boundary, use user's choice
                    if (!project.homeWall) return userAlignment;

                    // Check if wall midpoint is inside or outside boundary
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    const hw = project.homeWall;

                    const isInside = (midX >= hw.x && midX <= hw.x + hw.width &&
                        midY >= hw.y && midY <= hw.y + hw.height);

                    // Auto-select alignment based on position
                    if (isInside) {
                        return 'inside';  // Inside boundary -> thickness goes inward
                    } else {
                        return 'outside'; // Outside boundary -> thickness goes outward
                    }
                }

                elements.push(element);
                updateLayerCounts();
                updateDimensionDisplay();
            }

            function addSymbol(symbolType, x, y) {
                const config = symbols[symbolType];
                const element = {
                    type: 'symbol',
                    symbolType: symbolType,
                    x: x,
                    y: y,
                    rotation: 0,
                    scale: 1
                };

                // Copy architectural dimensions if they exist (to allow individual scaling)
                if (config.width) element.width = config.width;
                if (config.length) element.length = config.length;
                if (config.breadth) element.breadth = config.breadth;
                if (config.radius) element.radius = config.radius;
                if (config.steps) element.steps = config.steps;
                if (config.radius) element.radius = config.radius;

                elements.push(element);
                updateLayerCounts();
                redrawAll();
            }

            function addText(x, y) {
                const text = prompt('Enter text:');
                if (text) {
                    saveState(); // Save state before adding text
                    elements.push({
                        type: 'text',
                        text: text,
                        x: x,
                        y: y,
                        fontSize: 14,
                        color: '#1e293b'
                    });
                    updateLayerCounts();
                    redrawAll();
                }
            }

            function drawPreview(x1, y1, x2, y2) {
                ctx.save();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;

                switch (currentTool) {
                    case 'wall':
                        const thickFt = parseFloat(document.getElementById('wallThickness').value) || 0.5;
                        const thick = thickFt * SCALE;
                        ctx.lineWidth = thick;
                        ctx.strokeStyle = document.getElementById('wallColor').value;

                        let ox1 = x1, oy1 = y1, ox2 = x2, oy2 = y2;
                        // Smart alignment detection based on position
                        let align = document.getElementById('wallAlignment').value;
                        if (project.homeWall) {
                            const midX = (x1 + x2) / 2;
                            const midY = (y1 + y2) / 2;
                            const hw = project.homeWall;
                            const isInside = (midX >= hw.x && midX <= hw.x + hw.width &&
                                midY >= hw.y && midY <= hw.y + hw.height);
                            align = isInside ? 'inside' : 'outside';
                        }

                        if (align && align !== 'center') {
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            if (length > 0) {
                                const hW = project.homeWall;
                                const targetX = hW ? hW.x + hW.width / 2 : canvas.width / 2;
                                const targetY = hW ? hW.y + hW.height / 2 : canvas.height / 2;

                                let nx = -dy / length;
                                let ny = dx / length;
                                const midX = (x1 + x2) / 2;
                                const midY = (y1 + y2) / 2;
                                const dot = nx * (midX - targetX) + ny * (midY - targetY);
                                if (dot < 0) { nx = -nx; ny = -ny; }
                                if (align === 'inside') { nx = -nx; ny = -ny; }

                                const offset = thick / 2;
                                ox1 += nx * offset; oy1 += ny * offset;
                                ox2 += nx * offset; oy2 += ny * offset;
                            }
                        }

                        ctx.beginPath();
                        ctx.moveTo(ox1, oy1);
                        ctx.lineTo(ox2, oy2);
                        ctx.stroke();
                        drawWallDimension(x1, y1, x2, y2, document.getElementById('wallColor').value);
                        break;
                    case 'door':
                        drawDoor(x1, y1, x2, y2, true);
                        break;
                    case 'window':
                        drawWindow(x1, y1, x2, y2, true);
                        break;
                    case 'dimension':
                        drawDimensionLine(x1, y1, x2, y2);
                        break;
                }

                ctx.restore();
            }

            function drawElement(element) {
                ctx.save();

                // Highlight if selected
                if (element === selectedElement) {
                    ctx.save();
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;

                    if (element.type === 'text' || element.type === 'symbol') {
                        const config = symbols[element.symbolType];
                        ctx.save();
                        ctx.translate(element.x, element.y);
                        ctx.rotate(((element.rotation || 0) * Math.PI) / 180);

                        let w = 40, h = 40;
                        if (config?.isStair) {
                            const s = SCALE;
                            w = (element.width || config.width) * s * (element.scale || 1);
                            h = (element.length || config.length) * s * (element.scale || 1);
                            if (config.stairType === 'spiral') { w = (element.radius || config.radius) * 2 * s * (element.scale || 1); h = w; }
                            else if (config.stairType === 'lshape') { h = (element.breadth || config.breadth) * s * (element.scale || 1); } // L-shape is more complex, just use max dim for highlight
                        } else if (config) {
                            w = config.width * (element.scale || 1);
                            h = config.height * (element.scale || 1);
                        }
                        ctx.strokeRect(-w / 2 - 5, -h / 2 - 5, w + 10, h + 10);

                        // Draw Resize Handle for Stairs
                        if (config?.isStair) {
                            ctx.fillStyle = '#ef4444';
                            ctx.fillRect(w / 2, h / 2, 12, 12);
                        }
                        ctx.restore();
                    } else if (element.x1 !== undefined) {
                        // Calculate distance and angle for line-based elements
                        const dist = Math.sqrt(Math.pow(element.x2 - element.x1, 2) + Math.pow(element.y2 - element.y1, 2));
                        const ang = Math.atan2(element.y2 - element.y1, element.x2 - element.x1);
                        const thickFt = element.thickness || parseFloat(document.getElementById('wallThickness').value) || 0.5;
                        const thick = thickFt * SCALE;

                        ctx.save();
                        ctx.translate(element.x1, element.y1);
                        ctx.rotate(ang);
                        // Draw box around the total footprint
                        ctx.strokeRect(-4, -thick / 2 - 4, dist + 8, thick + 8);
                        ctx.restore();
                    }
                    ctx.restore();
                }

                switch (element.type) {
                    case 'wall':
                        ctx.strokeStyle = element.color;
                        ctx.lineWidth = (element.thickness || 0.5) * SCALE;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(element.x1, element.y1);
                        ctx.lineTo(element.x2, element.y2);
                        ctx.stroke();
                        drawWallDimension(element.x1, element.y1, element.x2, element.y2, element.color);

                        // Wall Selection Highlight
                        if (element === selectedElement) {
                            ctx.save();
                            ctx.strokeStyle = '#3b82f6'; // Blue selection color
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            // Draw parallel lines on both sides to highlight
                            const ang = Math.atan2(element.y2 - element.y1, element.x2 - element.x1);
                            const offset = (element.thickness / 2) + 4;

                            // Side 1
                            ctx.beginPath();
                            ctx.moveTo(element.x1 + offset * Math.sin(ang), element.y1 - offset * Math.cos(ang));
                            ctx.lineTo(element.x2 + offset * Math.sin(ang), element.y2 - offset * Math.cos(ang));
                            ctx.stroke();

                            // Side 2
                            ctx.beginPath();
                            ctx.moveTo(element.x1 - offset * Math.sin(ang), element.y1 + offset * Math.cos(ang));
                            ctx.lineTo(element.x2 - offset * Math.sin(ang), element.y2 + offset * Math.cos(ang));
                            ctx.stroke();

                            // Endpoints circles
                            ctx.fillStyle = '#3b82f6';
                            ctx.beginPath();
                            ctx.arc(element.x1, element.y1, 4, 0, Math.PI * 2);
                            ctx.arc(element.x2, element.y2, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                        break;
                    case 'door':
                        drawDoor(element.x1, element.y1, element.x2, element.y2, false, element);
                        break;
                    case 'window':
                        drawWindow(element.x1, element.y1, element.x2, element.y2, false);
                        break;
                    case 'dimension':
                        drawDimensionLine(element.x1, element.y1, element.x2, element.y2);
                        break;
                    case 'symbol':
                        drawSymbol(element);
                        break;
                    case 'text':
                        ctx.font = `${element.fontSize}px DM Sans`;
                        ctx.fillStyle = element.color;
                        ctx.fillText(element.text, element.x, element.y);
                        break;
                }

                ctx.restore();
            }

            function drawWallDimension(x1, y1, x2, y2, color) {
                if (!showMeasurements) return;
                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const lengthFt = (distance / SCALE).toFixed(1);
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                const angle = Math.atan2(y2 - y1, x2 - x1);

                ctx.save();
                ctx.translate(midX, midY);

                // Keep text readable (not upside down)
                let textAngle = angle;
                if (textAngle > Math.PI / 2 || textAngle < -Math.PI / 2) {
                    textAngle += Math.PI;
                }
                ctx.rotate(textAngle);

                // Offset text away from the wall line
                const offset = -25;
                ctx.translate(0, offset);

                // Enhanced font size and styling
                ctx.font = 'bold 14px DM Sans';
                const text = `${lengthFt} ft`;
                const tw = ctx.measureText(text).width;
                const padding = 8;

                // Enhanced Background with shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
                ctx.fillRect(-tw / 2 - padding, -12, tw + padding * 2, 24);

                // Reset shadow for border
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // Enhanced Border
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(-tw / 2 - padding, -12, tw + padding * 2, 24);

                // Text with better contrast
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, 0);

                ctx.restore();
            }

            function drawDoor(x1, y1, x2, y2, preview, element = null) {
                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const thicknessFt = parseFloat(document.getElementById('wallThickness').value);
                const thickness = thicknessFt * SCALE;

                // Get flip states
                const flippedHinge = element?.flippedHinge || false;
                const flippedSwing = element?.flippedSwing || false;

                ctx.save();
                ctx.translate(x1, y1);
                ctx.rotate(angle);

                // 1. Clear wall area
                ctx.fillStyle = 'white';
                ctx.fillRect(0, -thickness / 2, distance, thickness);

                // Handle Hinge Flip (Mirror along the wall length)
                if (flippedHinge) {
                    ctx.translate(distance, 0);
                    ctx.scale(-1, 1);
                }

                // Handle Swing Flip (Mirror across the wall thickness)
                if (flippedSwing) {
                    ctx.scale(1, -1);
                }

                // 2. Door Frame / Hinge Point
                ctx.strokeStyle = '#1e293b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -thickness / 2);
                ctx.lineTo(0, thickness / 2);
                ctx.stroke();

                // 3. Door Panel (Open at 90 degrees)
                ctx.beginPath();
                ctx.lineWidth = 2;
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -distance);
                ctx.stroke();

                // 4. Swing Arc
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.arc(0, 0, distance, 0, -Math.PI / 2, true);
                ctx.stroke();

                ctx.restore();
                if (!preview && showMeasurements) {
                    const lengthFt = (distance / SCALE).toFixed(1);
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;

                    ctx.save();
                    ctx.translate(midX, midY);

                    let textAngle = angle;
                    if (textAngle > Math.PI / 2 || textAngle < -Math.PI / 2) {
                        textAngle += Math.PI;
                    }
                    ctx.rotate(textAngle);

                    ctx.font = 'bold 11px DM Sans';
                    ctx.fillStyle = '#1e293b';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    const text = `D: ${lengthFt}'`;
                    const tw = ctx.measureText(text).width;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(-tw / 2 - 4, -25, tw + 8, 20);

                    ctx.fillStyle = '#1e293b';
                    ctx.fillText(text, 0, -15);
                    ctx.restore();
                }
            }

            function drawWindow(x1, y1, x2, y2, preview) {
                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const thicknessFt = parseFloat(document.getElementById('wallThickness').value);
                const thickness = thicknessFt * SCALE;

                ctx.save();
                ctx.translate(x1, y1);
                ctx.rotate(angle);

                // Fill background white to clear the wall
                ctx.fillStyle = 'white';
                ctx.fillRect(0, -thickness / 2, distance, thickness);

                // Draw window frame
                ctx.strokeStyle = '#1e293b';
                ctx.lineWidth = 1.5;
                ctx.strokeRect(0, -thickness / 2, distance, thickness);

                // Draw double lines inside (Architectural Window Style)
                ctx.beginPath();
                ctx.lineWidth = 1;
                ctx.moveTo(0, -thickness / 6);
                ctx.lineTo(distance, -thickness / 6);
                ctx.moveTo(0, thickness / 6);
                ctx.lineTo(distance, thickness / 6);
                ctx.stroke();

                ctx.restore();

                if (!preview && showWindowLabels && showMeasurements) {
                    // Calculate dimensions for display
                    const lengthFt = (distance / SCALE).toFixed(1);
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;

                    ctx.save();
                    ctx.translate(midX, midY);

                    // Align text with window angle
                    let textAngle = angle;
                    // Keep text readable (prevent upside down)
                    if (textAngle > Math.PI / 2 || textAngle < -Math.PI / 2) {
                        textAngle += Math.PI;
                    }
                    ctx.rotate(textAngle);

                    ctx.font = 'bold 11px DM Sans';
                    ctx.fillStyle = '#1e293b';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Draw background for text
                    const text = `W: ${lengthFt}'`;
                    const tw = ctx.measureText(text).width;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.fillRect(-tw / 2 - 4, -10, tw + 8, 20);

                    ctx.fillStyle = '#1e293b';
                    ctx.fillText(text, 0, 0);
                    ctx.restore();
                }
            }

            function drawDimensionLine(x1, y1, x2, y2) {
                if (!showMeasurements) return;
                ctx.strokeStyle = '#2563eb';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                const angle = Math.atan2(y2 - y1, x2 - x1);
                const arrowLength = 10;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x1 + arrowLength * Math.cos(angle + Math.PI / 6), y1 + arrowLength * Math.sin(angle + Math.PI / 6));
                ctx.moveTo(x1, y1);
                ctx.lineTo(x1 + arrowLength * Math.cos(angle - Math.PI / 6), y1 + arrowLength * Math.sin(angle - Math.PI / 6));
                ctx.stroke();

                const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                const measurement = (distance / SCALE).toFixed(1);
                ctx.font = 'bold 12px DM Sans';
                ctx.fillStyle = '#2563eb';
                ctx.textAlign = 'center';
                ctx.fillText(`${measurement} ft`, (x1 + x2) / 2, ((y1 + y2) / 2) - 5);
            }

            function drawRectangleDimensions(x, y, width, height, color) {
                ctx.save();
                ctx.font = 'bold 11px DM Sans';
                ctx.fillStyle = color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const lengthFt = (width / SCALE).toFixed(1);
                const breadthFt = (height / SCALE).toFixed(1);
                const areaFt = (lengthFt * breadthFt).toFixed(1);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fillRect(x + width / 2 - 35, y + height / 2 - 25, 70, 50);
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.strokeRect(x + width / 2 - 35, y + height / 2 - 25, 70, 50);

                ctx.fillStyle = color;
                ctx.fillText(`L: ${lengthFt}'`, x + width / 2, y + height / 2 - 12);
                ctx.fillText(`B: ${breadthFt}'`, x + width / 2, y + height / 2 + 3);
                ctx.fillText(`Area: ${areaFt} sq ft`, x + width / 2, y + height / 2 + 18);
                ctx.restore();
            }

            function drawSymbol(element) {
                const symbol = symbols[element.symbolType];
                if (!symbol) {
                    console.warn(`Furniture/Symbol type "${element.symbolType}" not found.`);
                    return;
                }

                ctx.save();
                ctx.translate(element.x, element.y);
                const rot = element.rotation || 0;
                ctx.rotate((rot * Math.PI) / 180);
                const currentScale = element.scale || 1;
                ctx.scale(currentScale, currentScale);

                if (symbol.isStair) {
                    drawStairs(element, symbol);
                    ctx.restore();
                    return;
                }

                if (symbol.isCompass) {
                    drawCompass(element, symbol);
                    ctx.restore();
                    return;
                }

                // Draw Architectural Blocks (Black Border, White/Empty Fill)
                ctx.strokeStyle = '#000000'; // Black Border
                ctx.lineWidth = 1; // Thinner for icons
                ctx.fillStyle = '#000000'; // Black Fill for Text/Icons

                // Common dimensions
                const w = (symbol.width || 40) * currentScale;
                const h = (symbol.height || 40) * currentScale;

                if (symbol.icon) {
                    // Use Material Symbols
                    // Font size should fit the height
                    const fontSize = Math.min(w, h);
                    ctx.font = `${fontSize}px "Material Symbols Outlined"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(symbol.icon, 0, 0);

                    // Optional: Draw Label below or small if needed
                    if (symbol.label) {
                        ctx.font = '10px Arial';
                        ctx.fillStyle = '#000000';
                        ctx.fillText(symbol.label, 0, h / 2 + 10);
                    }
                } else if (symbol.isShape) {
                    ctx.beginPath();
                    if (symbol.dash) ctx.setLineDash(symbol.dash);

                    if (symbol.shape === 'rect') {
                        ctx.rect(-w / 2, -h / 2, w, h);
                    } else if (symbol.shape === 'circle') {
                        ctx.arc(0, 0, w / 2, 0, Math.PI * 2);
                    } else if (symbol.shape === 'oval') {
                        ctx.ellipse(0, 0, w / 2, h / 2, 0, 0, Math.PI * 2);
                    } else if (symbol.shape === 'bed') {
                        // Draw Bed Frame
                        ctx.rect(-w / 2, -h / 2, w, h);
                        ctx.stroke(); // Draw frame first

                        // Draw Pillows
                        ctx.beginPath();
                        const pw = w * 0.35;
                        const ph = h * 0.2;
                        ctx.rect(-w / 2 + 5, -h / 2 + 5, pw, ph); // Left Pillow
                        ctx.rect(w / 2 - pw - 5, -h / 2 + 5, pw, ph); // Right Pillow

                        // Draw Sheet Fold
                        ctx.moveTo(-w / 2, -h / 2 + h * 0.35);
                        ctx.lineTo(w / 2, -h / 2 + h * 0.35);
                    }

                    ctx.stroke();

                    // Cross for shower etc
                    if (symbol.cross) {
                        ctx.beginPath();
                        ctx.moveTo(-w / 2, -h / 2);
                        ctx.lineTo(w / 2, h / 2);
                        ctx.moveTo(w / 2, -h / 2);
                        ctx.lineTo(-w / 2, h / 2);
                        ctx.stroke();
                    }

                    // Reset Dash
                    ctx.setLineDash([]);

                    // Draw Label
                    if (symbol.label) {
                        ctx.font = '10px Arial';
                        ctx.fillStyle = '#000000';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(symbol.label, 0, 0);
                    }
                } else if (symbol.emoji) {
                    // Fallback to emoji if no shape defined
                    ctx.font = `${symbol.height || 30}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(symbol.emoji, 0, 0);
                }

                ctx.restore();
            }

            function drawCompass(element, config) {
                const size = (config.width || 60) * (element.scale || 1);
                const r = size / 2;

                // Draw Compass Circle
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.strokeStyle = '#1e293b';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Draw Cross
                ctx.beginPath();
                ctx.moveTo(0, -r + 5);
                ctx.lineTo(0, r - 5);
                ctx.moveTo(-r + 5, 0);
                ctx.lineTo(r - 5, 0);
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Draw North Arrow (Red Tip)
                ctx.beginPath();
                ctx.moveTo(0, -r + 5);
                ctx.lineTo(-5, -5);
                ctx.lineTo(5, -5);
                ctx.closePath();
                ctx.fillStyle = '#ef4444'; // Red for North
                ctx.fill();

                // Draw South Arrow (Dark)
                ctx.beginPath();
                ctx.moveTo(0, r - 5);
                ctx.lineTo(-5, 5);
                ctx.lineTo(5, 5);
                ctx.closePath();
                ctx.fillStyle = '#1e293b';
                ctx.fill();

                // Labels (N, E, S, W)
                ctx.font = 'bold 12px DM Sans';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                ctx.fillStyle = '#ef4444';
                ctx.fillText('N', 0, -r - 12); // Above the circle

                ctx.fillStyle = '#1e293b';
                ctx.fillText('S', 0, r + 12);
                ctx.fillText('E', r + 12, 0);
                ctx.fillText('W', -r - 12, 0);
            }

            function drawStairs(element, config) {
                ctx.strokeStyle = '#64748b';
                ctx.lineWidth = 1.5;

                const s = SCALE;

                if (config.stairType === 'straight') {
                    const w = (element.width || config.width) * s;
                    const l = (element.length || config.length) * s;
                    const steps = element.steps || Math.round(l / s) || config.steps;

                    // Outline
                    ctx.strokeRect(-w / 2, -l / 2, w, l);

                    // Steps
                    for (let i = 1; i < steps; i++) {
                        const stepY = -l / 2 + (l / steps) * i;
                        ctx.beginPath();
                        ctx.moveTo(-w / 2, stepY);
                        ctx.lineTo(w / 2, stepY);
                        ctx.stroke();
                    }
                    // Direction Arrow
                    ctx.beginPath();
                    ctx.moveTo(0, l / 2 - 10);
                    ctx.lineTo(0, -l / 2 + 10);
                    ctx.lineTo(-5, -l / 2 + 20);
                    ctx.moveTo(0, -l / 2 + 10);
                    ctx.lineTo(5, -l / 2 + 20);
                    ctx.stroke();

                } else if (config.stairType === 'lshape') {
                    const w = (element.width || config.width) * s;
                    const l = (element.length || config.length) * s;
                    const b = (element.breadth || config.breadth) * s;

                    const stepsTotal = element.steps || Math.round((l + b) / s) || config.steps;
                    const stepsFirstRun = Math.round((l / (l + b - w)) * stepsTotal);
                    const stepsSecondRun = stepsTotal - stepsFirstRun;

                    ctx.beginPath();
                    ctx.moveTo(-w / 2, l / 2);
                    ctx.lineTo(-w / 2, -l / 2);
                    ctx.lineTo(b / 2, -l / 2);
                    ctx.lineTo(b / 2, -l / 2 + w);
                    ctx.lineTo(-w / 2 + w, -l / 2 + w);
                    ctx.lineTo(-w / 2 + w, l / 2);
                    ctx.closePath();
                    ctx.stroke();

                    // Steps for the first run
                    for (let i = 1; i < stepsFirstRun; i++) {
                        const stepY = l / 2 - (l / stepsFirstRun) * i;
                        ctx.beginPath();
                        ctx.moveTo(-w / 2, stepY);
                        ctx.lineTo(-w / 2 + w, stepY);
                        ctx.stroke();
                    }
                    // Steps for the second run
                    for (let i = 1; i < stepsSecondRun; i++) {
                        const stepX = -w / 2 + w + ((b - w) / stepsSecondRun) * i;
                        ctx.beginPath();
                        ctx.moveTo(stepX, -l / 2);
                        ctx.lineTo(stepX, -l / 2 + w);
                        ctx.stroke();
                    }

                } else if (config.stairType === 'spiral') {
                    const r = (element.radius || config.radius) * s;
                    // Outer circle
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, Math.PI * 2);
                    ctx.stroke();
                    // Inner pole
                    ctx.beginPath();
                    ctx.arc(0, 0, r * 0.2, 0, Math.PI * 2);
                    ctx.stroke();

                    for (let i = 0; i < config.steps; i++) {
                        const ang = (Math.PI * 2 / config.steps) * i;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(ang) * r * 0.2, Math.sin(ang) * r * 0.2);
                        ctx.lineTo(Math.cos(ang) * r, Math.sin(ang) * r);
                        ctx.stroke();
                    }
                }
                ctx.restore();
            }

            function drawAllRooms() {
                // pass 1: Backgrounds
                project.rooms.forEach(room => {
                    ctx.fillStyle = room.color + '20';
                    ctx.fillRect(room.x, room.y, room.width, room.height);
                });

                // pass 2: Labels Only (Walls are handled in redrawAll unified pass)
                project.rooms.forEach(room => {
                    if (room === selectedRoom) {
                        const wallThick = parseFloat(document.getElementById('wallThickness').value) * SCALE || (0.5 * SCALE);
                        ctx.save();
                        ctx.setLineDash([5, 5]);
                        ctx.strokeStyle = '#ef4444';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(room.x - wallThick / 2 - 4, room.y - wallThick / 2 - 4, room.width + wallThick + 8, room.height + wallThick + 8);
                        ctx.fillStyle = '#ef4444';
                        ctx.fillRect(room.x + room.width + wallThick / 2 - 6, room.y + room.height + wallThick / 2 - 6, 12, 12);
                        ctx.restore();
                    }

                    ctx.font = '32px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(room.icon, room.x + room.width / 2, room.y + room.height / 2 - 15);
                    ctx.font = 'bold 14px DM Sans';
                    ctx.fillStyle = '#1e293b';
                    ctx.fillText(room.name, room.x + room.width / 2, room.y + room.height / 2 + 20);
                    ctx.font = '11px DM Sans';
                    ctx.fillStyle = '#64748b';
                    ctx.fillText(`${room.length}' √ó ${room.breadth}'`, room.x + room.width / 2, room.y + room.height / 2 + 35);
                });
            }

            function redrawAll() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (isExporting) {
                    // FORCE White background (Opaque) for export
                    ctx.save();
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                }

                ctx.save();
                ctx.translate(offsetX, offsetY);

                if (project.homeWall && !isExporting) {
                    const { x, y, width, height } = project.homeWall;
                    ctx.fillStyle = '#f9fafb';
                    ctx.fillRect(x, y, width, height);
                }

                if (showGrid && !isExporting) drawGrid();

                // Meta info removed

                drawAllRooms();

                // Unified Structural Wall Pass
                const wallThickFt = parseFloat(document.getElementById('wallThickness').value) || 0.5;
                const wallThick = wallThickFt * SCALE;
                const wallColor = isExporting ? '#000000' : (document.getElementById('wallColor').value || '#1e293b');
                const segments = new Set();

                const addSegment = (x1, y1, x2, y2, specialThick = null, specialColor = null, alignment = 'center', targetX = null, targetY = null) => {
                    const r = v => Math.round(v);
                    const p1 = `${r(x1)},${r(y1)}|${r(x2)},${r(y2)}`;
                    const p2 = `${r(x2)},${r(y2)}|${r(x1)},${r(y1)}`;
                    if (!segments.has(p1) && !segments.has(p2)) {
                        const thickFt = (specialThick || wallThickFt);
                        const thick = thickFt * (isExporting ? 1.5 : 1) * SCALE;

                        let ox1 = x1, oy1 = y1, ox2 = x2, oy2 = y2;

                        if (alignment && alignment !== 'center') {
                            const dx = x2 - x1;
                            const dy = y2 - y1;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            if (length > 0) {
                                let nx = -dy / length;
                                let ny = dx / length;

                                if (targetX !== null && targetY !== null) {
                                    const midX = (x1 + x2) / 2;
                                    const midY = (y1 + y2) / 2;
                                    const dot = nx * (midX - targetX) + ny * (midY - targetY);
                                    if (dot < 0) { nx = -nx; ny = -ny; }

                                    if (alignment === 'inside') { nx = -nx; ny = -ny; }
                                }

                                const offset = thick / 2;  // Half thickness keeps line at boundary edge
                                ox1 += nx * offset; oy1 += ny * offset;
                                ox2 += nx * offset; oy2 += ny * offset;
                            }
                        }

                        ctx.strokeStyle = specialColor || wallColor;
                        ctx.lineWidth = thick;
                        ctx.lineCap = 'square';
                        ctx.beginPath();
                        ctx.moveTo(ox1, oy1);
                        ctx.lineTo(ox2, oy2);
                        ctx.stroke();
                        segments.add(p1);
                    }
                };

                // 1. Process Home Boundary Removed (Now handled as elements)
                /*
                if (project.homeWall) {
                    const { x, y, width, height } = project.homeWall;
                    addSegment(x, y, x + width, y, 10); // North
                    addSegment(x, y + height, x + width, y + height, 10); // South
                    addSegment(x, y, x, y + height, 10); // West
                    addSegment(x + width, y, x + width, y + height, 10); // East
                }
                */

                // 2. Process room walls
                project.rooms.forEach(room => {
                    const rx1 = room.x, ry1 = room.y, rx2 = room.x + room.width, ry2 = room.y + room.height;
                    const rMidX = rx1 + room.width / 2;
                    const rMidY = ry1 + room.height / 2;
                    // Room walls are typically interior, but we pass center for future use if needed
                    addSegment(rx1, ry1, rx2, ry1, 0.2, null, 'center', rMidX, rMidY); // North
                    addSegment(rx1, ry2, rx2, ry2, 0.2, null, 'center', rMidX, rMidY); // South
                    addSegment(rx1, ry1, rx1, ry2, 0.2, null, 'center', rMidX, rMidY); // West
                    addSegment(rx2, ry1, rx2, ry2, 0.2, null, 'center', rMidX, rMidY); // East
                });

                // 3. Process manual walls
                const homeMidX = project.homeWall ? project.homeWall.x + project.homeWall.width / 2 : canvas.width / 2;
                const homeMidY = project.homeWall ? project.homeWall.y + project.homeWall.height / 2 : canvas.height / 2;

                elements.forEach(element => {
                    if (element.type === 'wall') {
                        addSegment(element.x1, element.y1, element.x2, element.y2, element.thickness, element.color, element.alignment || 'center', homeMidX, homeMidY);
                        drawWallDimension(element.x1, element.y1, element.x2, element.y2, element.color);

                        // Draw Selection Highlight for Wall
                        if (element === selectedElement) {
                            ctx.save();
                            ctx.strokeStyle = '#3b82f6';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);

                            const dx = element.x2 - element.x1;
                            const dy = element.y2 - element.y1;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const ang = Math.atan2(dy, dx);
                            const thickFt = element.thickness || parseFloat(document.getElementById('wallThickness').value) || 0.5;
                            const thick = thickFt * SCALE;

                            let hx1 = element.x1, hy1 = element.y1, hx2 = element.x2, hy2 = element.y2;
                            const align = element.alignment;
                            if (align && align !== 'center') {
                                let nx = -dy / dist;
                                let ny = dx / dist;
                                const dot = nx * (((element.x1 + element.x2) / 2) - homeMidX) + ny * (((element.y1 + element.y2) / 2) - homeMidY);
                                if (dot < 0) { nx = -nx; ny = -ny; }
                                if (align === 'inside') { nx = -nx; ny = -ny; }
                                const off = thick / 2;
                                hx1 += nx * off; hy1 += ny * off;
                                hx2 += nx * off; hy2 += ny * off;
                            }

                            const offset = (thick / 2) + 4;

                            // Side 1
                            ctx.beginPath();
                            ctx.moveTo(hx1 + offset * Math.sin(ang), hy1 - offset * Math.cos(ang));
                            ctx.lineTo(hx2 + offset * Math.sin(ang), hy2 - offset * Math.cos(ang));
                            ctx.stroke();

                            // Side 2
                            ctx.beginPath();
                            ctx.moveTo(hx1 - offset * Math.sin(ang), hy1 + offset * Math.cos(ang));
                            ctx.lineTo(hx2 - offset * Math.sin(ang), hy2 + offset * Math.cos(ang));
                            ctx.stroke();

                            // Endpoints (Interaction points stay on original line)
                            ctx.fillStyle = '#3b82f6';
                            ctx.beginPath();
                            ctx.arc(element.x1, element.y1, 4, 0, Math.PI * 2);
                            ctx.arc(element.x2, element.y2, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        }
                    } else {
                        drawElement(element);
                    }
                });

                // 4. Draw Placement Preview (Ghost)
                if (placingItemType) {
                    const px = snapToGrid(mouseX);
                    const py = snapToGrid(mouseY);
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    if (placingItemType.startsWith('template_')) {
                        const key = placingItemType.replace('template_', '');
                        const config = roomConfig[key];
                        if (config) {
                            ctx.fillStyle = config.color + '40';
                            ctx.fillRect(px, py, config.defaultLength * SCALE, config.defaultBreadth * SCALE);
                            ctx.strokeStyle = config.color;
                            ctx.lineWidth = 2;
                            ctx.strokeRect(px, py, config.defaultLength * SCALE, config.defaultBreadth * SCALE);
                            ctx.font = '24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText(config.icon, px + (config.defaultLength * SCALE) / 2, py + (config.defaultBreadth * SCALE) / 2);
                        }
                    } else {
                        const config = symbols[placingItemType];
                        if (config) {
                            if (config.isStair) {
                                drawStairs(placingItemType, px, py);
                            } else {
                                ctx.font = '32px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText(config.emoji, px, py);
                            }
                        }
                    }
                    ctx.restore();
                }

                ctx.restore();
            }

            function dragSymbol(event, symbolType) {
                event.dataTransfer.setData('symbol', symbolType);

                // For mobile devices only: activate tap-to-place mode
                // Desktop keeps normal drag-and-drop
                const isMobile = window.innerWidth <= 992;
                if (isMobile && 'ontouchstart' in window) {
                    pickItem(symbolType);
                }

                // Auto-close mobile sidebar on drag
                const sidebar = document.getElementById('sidebarLeft');
                if (sidebar.classList.contains('mobile-active')) {
                    toggleMobileMenu();
                }
            }

            function updateDimensionDisplay() {
                document.getElementById('totalLength').textContent = project.totalLength || 0;
                document.getElementById('totalBreadth').textContent = project.totalBreadth || 0;
                if (!project.homeWall) {
                    document.getElementById('balanceLength').textContent = '0';
                    document.getElementById('balanceBreadth').textContent = '0';
                    return;
                }
                let maxUsedX = 0, maxUsedY = 0;
                const homeX = project.homeWall.x, homeY = project.homeWall.y;
                project.rooms.forEach(room => {
                    maxUsedX = Math.max(maxUsedX, (room.x - homeX + room.width) / SCALE);
                    maxUsedY = Math.max(maxUsedY, (room.y - homeY + room.height) / SCALE);
                });
                elements.forEach(element => {
                    if (element.type === 'wall' || element.type === 'door' || element.type === 'window') {
                        maxUsedX = Math.max(maxUsedX, (Math.max(element.x1, element.x2) - homeX) / SCALE);
                        maxUsedY = Math.max(maxUsedY, (Math.max(element.y1, element.y2) - homeY) / SCALE);
                    }
                });
                document.getElementById('balanceLength').textContent = Math.max(0, project.totalLength - maxUsedX).toFixed(1);
                document.getElementById('balanceBreadth').textContent = Math.max(0, project.totalBreadth - maxUsedY).toFixed(1);
            }

            function updateLayerCounts() {
                const counts = { home: project.homeWall ? 1 : 0, rooms: project.rooms.length, walls: 0, doorWindow: 0, furniture: 0 };
                elements.forEach(element => {
                    if (element.type === 'wall') counts.walls++;
                    else if (element.type === 'door' || element.type === 'window') counts.doorWindow++;
                    else if (element.type === 'symbol') counts.furniture++;
                });

                // Update UI only if elements exist
                const homeCnt = document.getElementById('homeCount');
                const roomCnt = document.getElementById('roomsCount');
                const wallCnt = document.getElementById('wallCount');
                const dwCnt = document.getElementById('doorWindowCount');
                const furnCnt = document.getElementById('furnitureCount');

                if (homeCnt) homeCnt.textContent = counts.home;
                if (roomCnt) roomCnt.textContent = counts.rooms;
                if (wallCnt) wallCnt.textContent = counts.walls;
                if (dwCnt) dwCnt.textContent = counts.doorWindow;
                if (furnCnt) furnCnt.textContent = counts.furniture;
            }

            function updateScale() {
                const oldScale = SCALE;
                SCALE = parseInt(document.getElementById('zoomRange').value);

                // Scale offsets proportionally to maintain view center
                if (oldScale > 0) {
                    const ratio = SCALE / oldScale;
                    offsetX *= ratio;
                    offsetY *= ratio;
                }

                // Sync grid snap with new scale
                const gridValue = parseFloat(document.getElementById('gridSelect').value);
                gridSnap = gridValue * SCALE;

                if (project.homeWall) {
                    const ratio = SCALE / oldScale;

                    // Keep the center of the project at the center of the canvas
                    project.homeWall.width = project.totalLength * SCALE;
                    project.homeWall.height = project.totalBreadth * SCALE;
                    project.homeWall.x = (canvas.width - project.homeWall.width) / 2;
                    project.homeWall.y = (canvas.height - project.homeWall.height) / 2;

                    project.rooms.forEach(room => {
                        // Coordinates relative to homeWall origin (top-left)
                        const relX = (room.x - (canvas.width - project.totalLength * oldScale) / 2) * ratio;
                        const relY = (room.y - (canvas.height - project.totalBreadth * oldScale) / 2) * ratio;

                        room.width = room.length * SCALE;
                        room.height = room.breadth * SCALE;
                        room.x = relX + project.homeWall.x;
                        room.y = relY + project.homeWall.y;
                    });

                    elements.forEach(el => {
                        if (el.type !== 'text' && el.type !== 'symbol') {
                            const relX1 = (el.x1 - (canvas.width - project.totalLength * oldScale) / 2) * ratio;
                            const relX2 = (el.x2 - (canvas.width - project.totalLength * oldScale) / 2) * ratio;
                            const relY1 = (el.y1 - (canvas.height - project.totalBreadth * oldScale) / 2) * ratio;
                            const relY2 = (el.y2 - (canvas.height - project.totalBreadth * oldScale) / 2) * ratio;
                            el.x1 = relX1 + project.homeWall.x;
                            el.x2 = relX2 + project.homeWall.x;
                            el.y1 = relY1 + project.homeWall.y;
                            el.y2 = relY2 + project.homeWall.y;
                        } else {
                            const relX = (el.x - (canvas.width - project.totalLength * oldScale) / 2) * ratio;
                            const relY = (el.y - (canvas.height - project.totalBreadth * oldScale) / 2) * ratio;
                            el.x = relX + project.homeWall.x;
                            el.y = relY + project.homeWall.y;
                        }
                    });
                }
                redrawAll();
            }

            function fitToScreen() {
                if (!project.homeWall) return;

                offsetX = 0;
                offsetY = 0;

                const padding = 60; // Extra visual padding in pixels
                const availableWidth = canvas.width - padding;
                const availableHeight = canvas.height - padding;

                // 4 side 3 feet show space = 6 feet extra total
                const marginFeet = 6;

                // If rotated 90 or 270, the mapping of project dimension to canvas dimension is swapped
                const scaleX = (rotation % 180 === 0) ? (availableWidth / (project.totalLength + marginFeet)) : (availableHeight / (project.totalLength + marginFeet));
                const scaleY = (rotation % 180 === 0) ? (availableHeight / (project.totalBreadth + marginFeet)) : (availableWidth / (project.totalBreadth + marginFeet));

                let optimalScale = Math.floor(Math.min(scaleX, scaleY));
                optimalScale = Math.max(5, Math.min(30, optimalScale));

                document.getElementById('zoomRange').value = optimalScale;
                updateScale();

                // Re-center after scale update
                const wallWidth = project.totalLength * SCALE;
                const wallHeight = project.totalBreadth * SCALE;
                project.homeWall.x = (canvas.width - wallWidth) / 2;
                project.homeWall.y = (canvas.height - wallHeight) / 2;

                redrawAll();
                showToast('üìè', 'Fit to screen (with 3ft margin)');
            }

            function toggleRotation() {
                rotation = (rotation + 90) % 360;
                const canvasEl = document.getElementById('designCanvas');
                canvasEl.style.transform = `rotate(${rotation}deg)`;
                showToast('üîÑ', `Rotated to ${rotation}¬∞`);
            }

            function updateGrid() {
                const gridValue = parseFloat(document.getElementById('gridSelect').value);
                gridSnap = gridValue * SCALE;
                redrawAll();
            }

            function toggleGrid() {
                showGrid = !showGrid;
                redrawAll();
            }

            function toggleSnap() {
                snapEnabled = !snapEnabled;
                showToast('üß≤', `Snap: ${snapEnabled ? 'ON' : 'OFF'}`);
            }

            function clearCanvas() {
                if (confirm('Clear all elements? (Home boundary and rooms will be kept)')) {
                    saveState();
                    project.floors[project.activeFloorIndex].elements = [];
                    elements = project.floors[project.activeFloorIndex].elements;
                    updateLayerCounts();
                    updateDimensionDisplay();
                    redrawAll();
                    showToast('‚úì', 'Elements cleared');
                }
            }

            function exportDesign() {
                if (!project.homeWall) {
                    showToast('‚ö†Ô∏è', 'Please create a project first!');
                    return;
                }
                const link = document.createElement('a');
                link.download = `${project.name || 'floor-plan'}.png`;
                link.href = canvas.toDataURL();
                link.click();
                showToast('‚úì', 'Design exported successfully!');
            }

            function saveProject() {
                if (!project.homeWall) {
                    showToast('‚ö†Ô∏è', 'Please create a project first!');
                    return;
                }
                const dataStr = JSON.stringify({ project: project, elements: elements });
                const link = document.createElement('a');
                link.download = `${project.name || 'floor-plan'}.json`;
                link.href = URL.createObjectURL(new Blob([dataStr], { type: 'application/json' }));
                link.click();
                showToast('‚úì', 'Project saved successfully!');
            }

            function loadProject() {
                document.getElementById('projectFileInput').click();
            }

            function handleFileUpload(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (!data.project || !data.elements) {
                            throw new Error('Invalid project file format');
                        }

                        // Backup current state for undo
                        saveState();

                        // Restore project and elements
                        project = data.project;

                        // Sync active floor elements
                        const activeFloor = project.floors[project.activeFloorIndex];
                        elements = activeFloor.elements || [];
                        project.rooms = activeFloor.rooms || [];

                        // Reset global view state
                        offsetX = 0;
                        offsetY = 0;
                        undoStack = [];
                        redoStack = [];

                        // If the file structure is old (elements outside floors), maintain compatibility
                        if (data.elements && elements.length === 0) {
                            elements = data.elements;
                            activeFloor.elements = elements;
                        }

                        // Refresh UI
                        updateFloorUI();
                        updateLayerCounts();
                        updateDimensionDisplay();
                        redrawAll();

                        // Hide welcome screen if it exists
                        const welcome = document.getElementById('welcomeScreen');
                        if (welcome) welcome.style.display = 'none';

                        showToast('‚úì', 'Project loaded successfully!');
                    } catch (err) {
                        console.error('Load Error:', err);
                        showToast('‚ùå', 'Failed to load project: ' + err.message);
                    }
                };
                reader.readAsText(file);

                // Reset input so the same file can be uploaded again if needed
                event.target.value = '';
            }

            // --- 3D VIEW LOGIC ---
            let is3DMode = false;
            const clock = new THREE.Clock(); // Time-based precision
            let scene3D, camera3D, renderer3D, controls3D;

            function toggle3DView() {
                if (!project.homeWall) {
                    showToast('‚ö†Ô∏è', 'Please create a project first!');
                    return;
                }

                is3DMode = !is3DMode;
                const btnText = document.getElementById('viewToggleText');
                const canvasEl = document.getElementById('designCanvas');
                const container = document.getElementById('threeContainer');
                const sidebar = document.getElementById('sidebarLeft');

                if (is3DMode) {
                    btnText.textContent = '2D';
                    canvasEl.style.display = 'none';
                    container.style.display = 'block';

                    const threeCtrls = document.getElementById('threeControls');
                    const toggleBtn = document.getElementById('threeControlsToggle');

                    if (threeCtrls.classList.contains('minimized')) {
                        threeCtrls.style.display = 'none';
                        toggleBtn.style.display = 'block';
                    } else {
                        threeCtrls.style.display = 'flex';
                        toggleBtn.style.display = 'none';
                    }

                    // Hide 2D toolbars with safety
                    const cToolbar = document.querySelector('.canvas-toolbar');
                    if (cToolbar) cToolbar.style.display = 'none';
                    const dBar = document.querySelector('.dimension-bar');
                    if (dBar) dBar.style.display = 'none';
                    const dGrid = document.querySelector('.dimension-grid');
                    if (dGrid) dGrid.style.display = 'none';

                    // Deactivate tools
                    document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                    sidebar.style.pointerEvents = 'none';
                    sidebar.style.opacity = '0.5';

                    init3D();

                    // Sync roof button state
                    const roofBtn = document.getElementById('roofBtn');
                    if (roofBtn) {
                        roofBtn.querySelector('.text').textContent = `Roof: ${showRoof ? 'ON' : 'OFF'}`;
                        roofBtn.classList.toggle('active', !showRoof);
                    }

                    showToast('üè†', 'Interactive 3D View Active');
                } else {
                    btnText.textContent = '3D';
                    canvasEl.style.display = 'block';
                    container.style.display = 'none';

                    document.getElementById('threeControls').style.display = 'none';
                    document.getElementById('threeControlsToggle').style.display = 'none';

                    // Show 2D toolbars with safety
                    const cToolbarShow = document.querySelector('.canvas-toolbar');
                    if (cToolbarShow) cToolbarShow.style.display = 'flex';
                    const dBarShow = document.querySelector('.dimension-bar');
                    if (dBarShow) dBarShow.style.display = 'grid';
                    const dGridShow = document.querySelector('.dimension-grid');
                    if (dGridShow) dGridShow.style.display = 'grid';

                    sidebar.style.pointerEvents = 'auto';
                    sidebar.style.opacity = '1';

                    // Exit walk mode if active
                    if (isWalkMode) toggleWalkMode();

                    // Reactivate select tool
                    selectTool('select');

                    if (renderer3D) {
                        renderer3D.setAnimationLoop(null);
                        container.innerHTML = '';
                        renderer3D.dispose();
                    }
                }
            }

            let isWalkMode = false;
            let showRoof = true;
            let walkSpeed = 6;
            let walkKeys = {};
            let headBob = 0;
            let animatedElements = []; // { mesh, type, originalRotation, targetRotation, currentRotation }

            function toggleRoof() {
                showRoof = !showRoof;
                const btn = document.getElementById('roofBtn');
                if (btn) {
                    btn.querySelector('.text').textContent = `Roof: ${showRoof ? 'ON' : 'OFF'}`;
                    btn.classList.toggle('active', !showRoof);
                }

                if (scene3D) {
                    scene3D.traverse(obj => {
                        if (obj.userData && obj.userData.isRoof) {
                            obj.visible = showRoof;
                        }
                    });
                }
            }

            // Virtual Joystick Logic
            const joystick = document.getElementById('virtualJoystick');
            const knob = document.getElementById('joystickKnob');
            let joystickActive = false;
            let joystickOrigin = { x: 0, y: 0 };
            let joystickVector = { x: 0, y: 0 };

            joystick.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                const touch = e.touches[0];
                const rect = joystick.getBoundingClientRect();
                joystickOrigin = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                updateJoystick(touch.clientX, touch.clientY);
            });

            joystick.addEventListener('touchmove', (e) => {
                if (!joystickActive) return;
                e.preventDefault();
                const touch = e.touches[0];
                updateJoystick(touch.clientX, touch.clientY);
            });

            joystick.addEventListener('touchend', (e) => {
                joystickActive = false;
                joystickVector = { x: 0, y: 0 };
                knob.style.transform = `translate(0px, 0px)`;
                // Reset keys
                walkKeys['ArrowUp'] = false;
                walkKeys['ArrowDown'] = false;
                walkKeys['ArrowLeft'] = false;
                walkKeys['ArrowRight'] = false;
            });

            function updateJoystick(clientX, clientY) {
                const maxDist = 35; // Max radius
                let dx = clientX - joystickOrigin.x;
                let dy = clientY - joystickOrigin.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > maxDist) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * maxDist;
                    dy = Math.sin(angle) * maxDist;
                }

                knob.style.transform = `translate(${dx}px, ${dy}px)`;

                // Map to keys
                // Thresholds
                const threshold = 10;
                walkKeys['ArrowUp'] = dy < -threshold;
                walkKeys['ArrowDown'] = dy > threshold;
                walkKeys['ArrowLeft'] = dx < -threshold;
                walkKeys['ArrowRight'] = dx > threshold;
            }

            // Touch Look (Right side of screen)
            let walkLookX = 0, walkLookY = 0;
            window.addEventListener('touchstart', (e) => {
                if (!isWalkMode) return;
                // Only tracking looking on right half if joystick is on left
                if (e.touches[0].clientX > window.innerWidth / 2) {
                    walkLookX = e.touches[0].clientX;
                    walkLookY = e.touches[0].clientY;
                }
            });

            window.addEventListener('touchmove', (e) => {
                if (!isWalkMode) return;
                // If touch is on joystick, ignore here (handled by joystick)
                // But touchmove might fire for multiple touches
                for (let i = 0; i < e.touches.length; i++) {
                    const t = e.touches[i];
                    if (t.target === joystick || t.target === knob) continue;

                    if (t.clientX > window.innerWidth / 2) {
                        const dx = t.clientX - walkLookX;
                        const dy = t.clientY - walkLookY;

                        const sensitivity = 0.005;
                        camera3D.rotateY(-dx * sensitivity);
                        camera3D.rotation.order = 'YXZ';
                        let newPitch = camera3D.rotation.x - dy * sensitivity;
                        camera3D.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, newPitch));
                        camera3D.rotation.z = 0;

                        walkLookX = t.clientX;
                        walkLookY = t.clientY;
                    }
                }
            });

            function toggleWalkMode() {
                isWalkMode = !isWalkMode;
                const btn = document.getElementById('walkBtn');
                // const hint = document.getElementById('walkHint'); // Removed
                const joystickEl = document.getElementById('virtualJoystick');
                const lookHint = document.getElementById('techLookHint');

                btn.querySelector('.text').textContent = `Walk Mode: ${isWalkMode ? 'ON' : 'OFF'}`;
                btn.classList.toggle('active', isWalkMode);
                // hint.style.display = isWalkMode ? 'block' : 'none'; // Removed

                // Check if mobile (simple check)
                const isMobile = window.innerWidth < 768 || 'ontouchstart' in window;

                if (isWalkMode) {
                    controls3D.enabled = false;
                    camera3D.position.y = 5.5 * 15;
                    camera3D.lookAt(0, 5.5 * 15, 0);

                    if (isMobile) {
                        joystickEl.style.display = 'block';
                        lookHint.style.display = 'block';
                    } else {
                        renderer3D.domElement.requestPointerLock();
                    }

                    window.addEventListener('keydown', handleWalkKeydown);
                    window.addEventListener('keyup', handleWalkKeyup);
                    window.addEventListener('mousemove', handleWalkMouse);
                    window.addEventListener('wheel', handleWalkWheel, { passive: false });
                    showToast('üö∂', 'Walk mode active!');
                } else {
                    controls3D.enabled = true;
                    if (document.pointerLockElement) document.exitPointerLock();
                    joystickEl.style.display = 'none';
                    lookHint.style.display = 'none';

                    window.removeEventListener('keydown', handleWalkKeydown);
                    window.removeEventListener('keyup', handleWalkKeyup);
                    window.removeEventListener('mousemove', handleWalkMouse);
                    window.removeEventListener('wheel', handleWalkWheel);

                    // Reset FOV when leaving walk mode
                    if (camera3D) {
                        camera3D.fov = 45;
                        camera3D.updateProjectionMatrix();
                    }
                }
            }

            function handleWalkKeydown(e) { walkKeys[e.code] = true; }
            function handleWalkKeyup(e) { walkKeys[e.code] = false; }

            function handleWalkMouse(e) {
                if (!isWalkMode) return;
                const sensitivity = 0.002;
                camera3D.rotateY(-e.movementX * sensitivity);

                camera3D.rotation.order = 'YXZ'; // Prevent gimble lock
                let newPitch = camera3D.rotation.x - e.movementY * sensitivity;
                camera3D.rotation.x = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, newPitch));
                camera3D.rotation.z = 0;
            }

            function handleWalkWheel(e) {
                if (!isWalkMode) return;
                e.preventDefault();

                // Adjust Field Of View (Zoom)
                const zoomSensitivity = 0.05;
                camera3D.fov += e.deltaY * zoomSensitivity;

                // Clamp FOV between 20 (zoomed in) and 90 (wide angle)
                camera3D.fov = Math.max(20, Math.min(90, camera3D.fov));
                camera3D.updateProjectionMatrix();
            }

            // --- 3D Tour Logic ---
            let tourPath = []; // Array of { type: 'move'|'rotate', target: Vector3|null }
            let isTouring = false;
            let tourStep = 0;
            let tourProgress = 0;
            let TOUR_MOVE_SPEED = 30; // units/sec
            let TOUR_ROT_SPEED = (Math.PI * 2) / 5; // 5s full rotation

            function updateTourSpeed() {
                const val = parseInt(document.getElementById('tourSpeedRange') ? document.getElementById('tourSpeedRange').value : 10);
                const factor = val / 10;
                TOUR_MOVE_SPEED = 30 * factor;
                TOUR_ROT_SPEED = ((Math.PI * 2) / 5) * factor;
            }

            function generateSmartTourPath() {
                const path = [];
                // Simple 360 cinematic orbit
                path.push({ type: 'orbit' });
                return path;
            }

            function toggleTour() {
                isTouring = !isTouring;
                const btn = document.getElementById('tourBtn');

                if (isTouring) {
                    if (!project.homeWall) {
                        showToast('‚ö†Ô∏è', 'Project not ready!');
                        isTouring = false;
                        return;
                    }

                    tourPath = generateSmartTourPath();

                    if (tourPath.length === 0) {
                        showToast('‚ö†Ô∏è', 'Could not generate tour path.');
                        isTouring = false;
                        return;
                    }

                    btn.classList.add('active');
                    controls3D.enabled = false;

                    // Move camera to start immediately
                    if (tourPath[0].target) camera3D.position.copy(tourPath[0].target);

                    tourStep = 0;
                    tourProgress = 0; // For rotation or Lerp
                    showToast('üé¨', 'Starting Smart Tour...');
                } else {
                    btn.classList.remove('active');
                    controls3D.enabled = true;
                    showToast('‚èπÔ∏è', 'Tour Stopped');
                }
            }

            function updateTour(delta) {
                if (!isTouring || tourStep >= tourPath.length) {
                    if (isTouring) {
                        isTouring = false;
                        controls3D.enabled = true;
                        document.getElementById('tourBtn').classList.remove('active');
                        showToast('‚úÖ', 'Tour Completed');
                    }
                    return;
                }

                const step = tourPath[tourStep];

                if (step.type === 'move') {
                    const target = step.target;
                    const dist = camera3D.position.distanceTo(target);
                    const moveStep = TOUR_MOVE_SPEED * delta;

                    if (dist < moveStep) {
                        camera3D.position.copy(target);
                        tourStep++;
                    } else {
                        const dir = new THREE.Vector3().subVectors(target, camera3D.position).normalize();
                        camera3D.position.add(dir.multiplyScalar(moveStep));

                        const lookTarget = target.clone();
                        lookTarget.y = camera3D.position.y;
                        camera3D.lookAt(lookTarget);
                    }
                } else if (step.type === 'rotate') {
                    const rotStep = TOUR_ROT_SPEED * delta;
                    camera3D.rotation.y -= rotStep;
                    tourProgress += rotStep;

                    if (tourProgress >= Math.PI * 2) {
                        tourProgress = 0;
                        tourStep++;
                    }
                } else if (step.type === 'orbit') {
                    const rotStep = TOUR_ROT_SPEED * delta;
                    tourProgress += rotStep;

                    const unit = 15;
                    const w = (project.totalLength || 40) * unit;
                    const h = (project.totalBreadth || 30) * unit;
                    const dist = Math.max(w, h) * 1.8;
                    const camHeight = dist * 0.7;

                    // Orbit calculation
                    camera3D.position.x = Math.sin(tourProgress) * dist;
                    camera3D.position.z = Math.cos(tourProgress) * dist;
                    camera3D.position.y = camHeight;

                    // Always look at house center
                    camera3D.lookAt(0, camHeight * 0.3, 0);

                    if (tourProgress >= Math.PI * 2) {
                        tourProgress = 0;
                        tourStep++;
                    }
                }
            }

            // --- VIDEO RECORDING LOGIC ---
            let isRecording = false;
            let mediaRecorder;
            let recordedChunks = [];

            function toggleRecording() {
                if (!isRecording) {
                    startRecording();
                } else {
                    stopRecording();
                }
            }

            function startRecording() {
                if (!renderer3D || !renderer3D.domElement) {
                    showToast('‚ö†Ô∏è', '3D view not initialized!');
                    return;
                }

                const canvas = renderer3D.domElement;

                // captureStream(30) captures the canvas content at 30 FPS.
                // preserveDrawingBuffer: true in renderer init ensures stable capture.

                try {
                    const stream = canvas.captureStream(30); // 30 FPS

                    // Try to find supported mime type
                    const types = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm'];
                    let selectedType = types.find(t => MediaRecorder.isTypeSupported(t)) || '';

                    mediaRecorder = new MediaRecorder(stream, { mimeType: selectedType });
                    recordedChunks = [];

                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) recordedChunks.push(event.data);
                    };

                    mediaRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.style.display = 'none';
                        a.href = url;
                        a.download = `floor-plan-3d-${new Date().getTime()}.webm`;
                        document.body.appendChild(a);
                        a.click();
                        setTimeout(() => {
                            document.body.removeChild(a);
                            window.URL.revokeObjectURL(url);
                        }, 100);
                        showToast('‚úÖ', 'Recording saved & downloaded!');
                    };

                    mediaRecorder.start();
                    isRecording = true;
                    updateRecordingUI();
                    showToast('üî¥', 'Recording started...');
                } catch (err) {
                    console.error('Recording Error:', err);
                    showToast('‚ùå', 'Recording failed: ' + err.message);
                }
            }

            function stopRecording() {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }
                isRecording = false;
                updateRecordingUI();
            }

            function updateRecordingUI() {
                const btn = document.getElementById('recordBtn');
                if (!btn) return;
                const text = btn.querySelector('.text');
                const icon = btn.querySelector('.material-symbols-outlined');
                if (isRecording) {
                    btn.classList.add('active');
                    text.textContent = 'Recording...';
                    icon.textContent = 'stop_circle';
                    btn.title = "Stop Recording";
                } else {
                    btn.classList.remove('active');
                    text.textContent = 'Record';
                    icon.textContent = 'videocam';
                    btn.title = "Record Video";
                }
            }

            function updateWalkMotion() {
                if (!isWalkMode) return;

                const direction = new THREE.Vector3();
                const front = new THREE.Vector3();
                const right = new THREE.Vector3();

                camera3D.getWorldDirection(front);
                front.y = 0;
                front.normalize();

                right.crossVectors(camera3D.up, front).normalize();

                if (walkKeys['ArrowUp'] || walkKeys['KeyW']) direction.add(front);
                if (walkKeys['ArrowDown'] || walkKeys['KeyS']) direction.sub(front);
                if (walkKeys['ArrowLeft'] || walkKeys['KeyA']) direction.add(right);
                if (walkKeys['ArrowRight'] || walkKeys['KeyD']) direction.sub(right);

                if (direction.length() > 0) {
                    direction.normalize().multiplyScalar(walkSpeed);
                    camera3D.position.add(direction);

                    // Head bobbing logic
                    headBob += 0.15;
                    camera3D.position.y = (5.5 * 15) + Math.sin(headBob) * 2;
                }

                // Interactive Door Animation (Proximity)
                animatedElements.forEach(item => {
                    if (item.type === 'door') {
                        const dist = camera3D.position.distanceTo(item.pivot.position);
                        const openAngle = -Math.PI / 2.2;
                        // Open door if closer than 60 units (approx 4ft)
                        const target = dist < 65 ? openAngle : 0;
                        item.pivot.rotation.y += (target - item.pivot.rotation.y) * 0.1;
                    }
                });
            }

            function init3D() {
                const container = document.getElementById('threeContainer');
                // Force a reflow check or use offset dimensions
                let width = container.offsetWidth || 800;
                let height = container.offsetHeight || 600;

                if (width === 0 || height === 0) {
                    const wrapper = container.parentElement;
                    width = wrapper.clientWidth;
                    height = wrapper.clientHeight;
                }

                // Scene setup
                scene3D = new THREE.Scene();

                if (project.envTexture) {
                    const loader = new THREE.TextureLoader();
                    const texture = loader.load(project.envTexture);
                    texture.mapping = THREE.EquirectangularReflectionMapping;
                    scene3D.background = texture;
                    scene3D.environment = texture;
                } else {
                    scene3D.background = new THREE.Color(0xf8fafc); // Slate-50
                }

                // Camera
                camera3D = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
                camera3D.position.set(200, 400, 600);

                // Renderer
                renderer3D = new THREE.WebGLRenderer({
                    antialias: true,
                    logarithmicDepthBuffer: true,
                    preserveDrawingBuffer: true // Required for clear video/image capture
                });
                renderer3D.setSize(width, height);
                renderer3D.shadowMap.enabled = true;
                renderer3D.shadowMap.type = THREE.PCFSoftShadowMap;

                // Clear container just in case and append
                container.innerHTML = '';
                container.appendChild(renderer3D.domElement);

                animatedElements = []; // Reset animations on init
                tourTargets = []; // Reset tour targets

                // Controls
                controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
                controls3D.enableDamping = true;
                controls3D.dampingFactor = 0.05;

                // Limit rotation to upper hemisphere (Top/Side view only, no bottom view)
                controls3D.maxPolarAngle = Math.PI / 2;
                controls3D.minPolarAngle = 0;

                // Enable Panning (Right click drag)
                controls3D.enablePan = true;
                controls3D.screenSpacePanning = true;

                // Zoom limits
                controls3D.minDistance = 10;
                controls3D.maxDistance = 5000;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene3D.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
                directionalLight.position.set(300, 800, 400);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene3D.add(directionalLight);

                // Building Slabs (Floors) and Roof
                const unit = 15;
                const homeW = project.totalLength;
                const homeH = project.totalBreadth;
                const totalW3d = homeW * unit;
                const totalH3d = homeH * unit;

                // 3D Floor Grid removed as per request

                // Giant Ground Plane (Infinite Horizon Style)
                const groundSize = 10000;
                const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
                let groundMat;
                if (project.groundTexture) {
                    const texture = new THREE.TextureLoader().load(project.groundTexture);
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    // Standard repeat: 1 repeat per 10 feet (150 units at 15 SCALE)
                    texture.repeat.set(groundSize / (10 * unit), groundSize / (10 * unit));
                    groundMat = new THREE.MeshStandardMaterial({ map: texture });
                } else {
                    groundMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee }); // Light gray ground
                }
                const groundPlane = new THREE.Mesh(groundGeo, groundMat);
                groundPlane.rotation.x = -Math.PI / 2;
                groundPlane.position.y = -1; // Slightly below zero to avoid z-fighting with slabs
                groundPlane.receiveShadow = true;
                scene3D.add(groundPlane);

                // Loop through all floors
                project.floors.forEach((floor, fIndex) => {
                    const elevation3d = floor.elevation * unit;
                    const floorHeight3d = floor.height * unit;
                    const fW3d = (floor.length || project.totalLength) * unit;
                    const fH3d = (floor.breadth || project.totalBreadth) * unit;
                    const slabThick3d = 0.5 * unit; // 6 inch slab
                    const floorTex = floor.floorTexture || project.defaultFloorTexture;

                    const pxTo3d = (px, py) => {
                        const hw = floor.homeWall || project.floors[0].homeWall;
                        if (!hw) return { x: 0, z: 0 };
                        const x = (px - hw.x) / hw.width * fW3d - fW3d / 2;
                        const z = (py - hw.y) / hw.height * fH3d - fH3d / 2;
                        return { x, z };
                    };

                    // Floor Slab (Solid)
                    const slabGeo = new THREE.BoxGeometry(fW3d + 4, slabThick3d, fH3d + 4);
                    let slabMat;
                    // Support both asset keys, data URLs, and direct file paths
                    if (floorTex) {
                        const texUrl = ASSETS[floorTex] || floorTex;
                        const texture = new THREE.TextureLoader().load(texUrl,
                            // onLoad
                            () => redrawAll(),
                            // onProgress
                            undefined,
                            // onError
                            () => { console.warn(`Failed to load texture: ${texUrl}`); }
                        );
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set((floor.length || project.totalLength) / 5, (floor.breadth || project.totalBreadth) / 5);
                        slabMat = new THREE.MeshStandardMaterial({ map: texture });
                    } else if (project.groundTexture) {
                        const texture = new THREE.TextureLoader().load(project.groundTexture);
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                        texture.repeat.set(floor.length / 10, floor.breadth / 10);
                        slabMat = new THREE.MeshStandardMaterial({ map: texture });
                    } else {
                        slabMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                    }
                    const roofMat = new THREE.MeshStandardMaterial({ color: 0x808080 }); // Gray roof
                    const slab = new THREE.Mesh(slabGeo, slabMat);
                    slab.position.set(0, elevation3d - slabThick3d / 2, 0);
                    slab.receiveShadow = true;
                    scene3D.add(slab);

                    // Add Roof Slab if this is the top floor
                    if (fIndex === project.floors.length - 1) {
                        const roof = new THREE.Mesh(slabGeo, roofMat);
                        roof.position.set(0, elevation3d + floorHeight3d, 0);
                        roof.userData = { isRoof: true };
                        roof.visible = showRoof; // Respect showRoof status
                        roof.castShadow = true;
                        scene3D.add(roof);
                    }

                    const wallRegistry = new Set();
                    function add3DWall(x1, z1, x2, z2, h, t, c, yOff = 0, c2 = null, texKey = null) {
                        const r = v => Math.round(v);
                        const pOffset = yOff !== 0 ? `|Y${r(yOff)}` : '';
                        const pHeight = `|H${r(h)}`;
                        const p1 = `${r(x1)},${r(z1)}|${r(x2)},${r(z2)}${pOffset}${pHeight}`;
                        const p2 = `${r(x2)},${r(z2)}|${r(x1)},${r(z1)}${pOffset}${pHeight}`;
                        if (wallRegistry.has(p1) || wallRegistry.has(p2)) return;

                        const dx = x2 - x1;
                        const dz = z2 - z1;
                        const length = Math.sqrt(dx * dx + dz * dz);
                        const angle = Math.atan2(dz, dx);

                        const geo = new THREE.BoxGeometry(length, h, t);

                        let materials;
                        const activeTex = texKey || project.defaultWallTexture;

                        if (activeTex && ASSETS[activeTex]) {
                            const tex = new THREE.TextureLoader().load(ASSETS[activeTex]);
                            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
                            tex.repeat.set(length / (unit * 2), h / (unit * 2));
                            materials = new THREE.MeshStandardMaterial({ map: tex });
                        } else if (c2 && c2 !== c) {
                            const mat1 = new THREE.MeshStandardMaterial({ color: c });
                            const mat2 = new THREE.MeshStandardMaterial({ color: c2 });
                            materials = [mat1, mat1, mat1, mat1, mat1, mat2];
                        } else {
                            materials = new THREE.MeshStandardMaterial({ color: c });
                        }

                        const wall = new THREE.Mesh(geo, materials);

                        wall.position.set(x1 + dx / 2, elevation3d + yOff + h / 2, z1 + dz / 2);
                        wall.rotation.y = -angle;
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        scene3D.add(wall);
                        wallRegistry.add(p1);
                    }

                    // 1. Separate Elements
                    const walls = [];
                    const holes = [];
                    const symbolElements = [];

                    floor.elements.forEach(el => {
                        if (el.type === 'wall') walls.push(el);
                        else if (el.type === 'door' || el.type === 'window') holes.push(el);
                        else if (el.type === 'symbol') symbolElements.push(el);
                    });

                    // Add room boundaries to walls array so they can be cut for doors/windows
                    floor.rooms.forEach(room => {
                        const rw = room.width || (room.length * SCALE);
                        const rh = room.height || (room.breadth * SCALE);
                        const rColor = room.color || '#475569';
                        const rThick = 0.2; // Standard interior wall thickness for rooms in feet

                        walls.push({ type: 'wall', x1: room.x, y1: room.y, x2: room.x + rw, y2: room.y, color: rColor, thickness: rThick });
                        walls.push({ type: 'wall', x1: room.x, y1: room.y + rh, x2: room.x + rw, y2: room.y + rh, color: rColor, thickness: rThick });
                        walls.push({ type: 'wall', x1: room.x, y1: room.y, x2: room.x, y2: room.y + rh, color: rColor, thickness: rThick });
                        walls.push({ type: 'wall', x1: room.x + rw, y1: room.y, x2: room.x + rw, y2: room.y + rh, color: rColor, thickness: rThick });
                    });

                    // 2. Process Walls (Cut for openings)
                    walls.forEach(wall => {
                        const wx = wall.x2 - wall.x1;
                        const wy = wall.y2 - wall.y1;
                        const wallLenSq = wx * wx + wy * wy;
                        if (wallLenSq < 1) return; // Skip zero length
                        const wallLen = Math.sqrt(wallLenSq);

                        const cuts = [];

                        holes.forEach(hole => {
                            // Check collinearity and overlap
                            const hmx = (hole.x1 + hole.x2) / 2;
                            const hmy = (hole.y1 + hole.y2) / 2;

                            // Distance from hole center to wall line
                            const cross = wx * (hmy - wall.y1) - wy * (hmx - wall.x1);
                            const dist = Math.abs(cross) / wallLen;

                            if (dist > 15) return; // Not on wall (tolerance)

                            // Project hole onto wall vector
                            const tStart = ((hole.x1 - wall.x1) * wx + (hole.y1 - wall.y1) * wy) / wallLenSq;
                            const tEnd = ((hole.x2 - wall.x1) * wx + (hole.y2 - wall.y1) * wy) / wallLenSq;

                            const t0 = Math.min(tStart, tEnd);
                            const t1 = Math.max(tStart, tEnd);

                            // Overlap check
                            if (t1 <= 0.01 || t0 >= 0.99) return;

                            cuts.push({ start: Math.max(0, t0), end: Math.min(1, t1) });

                            // Sync Props: Wall -> Hole (Ensure seamless look)
                            if (wall.color) hole.color = wall.color;
                            if (wall.color2) hole.color2 = wall.color2;
                            if (wall.thickness) hole.thickness = wall.thickness;
                            if (wall.texture) hole.texture = wall.texture;
                        });

                        // Sort and Merge Cuts
                        cuts.sort((a, b) => a.start - b.start);
                        const merged = [];
                        if (cuts.length > 0) {
                            let curr = cuts[0];
                            for (let i = 1; i < cuts.length; i++) {
                                if (cuts[i].start < curr.end + 0.01) { // Merge overlapping/touching
                                    curr.end = Math.max(curr.end, cuts[i].end);
                                } else {
                                    merged.push(curr);
                                    curr = cuts[i];
                                }
                            }
                            merged.push(curr);
                        }

                        // Draw Wall Segments
                        let currentT = 0;
                        const drawSeg = (tA, tB) => {
                            if (tB - tA < 0.01) return; // Skip tiny segments
                            let sx1 = wall.x1 + wx * tA;
                            let sy1 = wall.y1 + wy * tA;
                            let sx2 = wall.x1 + wx * tB;
                            let sy2 = wall.y1 + wy * tB;

                            // Apply Wall Alignment Offset in 2D before converting to 3D
                            const align = wall.alignment;
                            if (align && align !== 'center') {
                                const hW = floor.homeWall || project.floors[0].homeWall;
                                const targetX = hW ? hW.x + hW.width / 2 : canvas.width / 2;
                                const targetY = hW ? hW.y + hW.height / 2 : canvas.height / 2;

                                const dx = wall.x2 - wall.x1;
                                const dy = wall.y2 - wall.y1;
                                const len = Math.sqrt(dx * dx + dy * dy);
                                if (len > 0) {
                                    let nx = -dy / len;
                                    let ny = dx / len;
                                    const midX = (wall.x1 + wall.x2) / 2;
                                    const midY = (wall.y1 + wall.y2) / 2;
                                    const dot = nx * (midX - targetX) + ny * (midY - targetY);
                                    if (dot < 0) { nx = -nx; ny = -ny; }
                                    if (align === 'inside') { nx = -nx; ny = -ny; }

                                    const offset = (wall.thickness || 0.5) * SCALE / 2;
                                    sx1 += nx * offset; sy1 += ny * offset;
                                    sx2 += nx * offset; sy2 += ny * offset;
                                }
                            }

                            const p1 = pxTo3d(sx1, sy1);
                            const p2 = pxTo3d(sx2, sy2);
                            const thick = (wall.thickness || 0.5) * unit;
                            const wHeight = wall.height ? (wall.height * unit) : floorHeight3d;

                            add3DWall(p1.x, p1.z, p2.x, p2.z, wHeight, thick, wall.color || '#475569', 0, wall.color2, wall.texture);
                        };

                        merged.forEach(cut => {
                            drawSeg(currentT, cut.start);
                            currentT = cut.end;
                        });
                        drawSeg(currentT, 1.0);
                    });

                    // 3. Render Holes (Doors/Windows)
                    holes.forEach(el => {
                        const p1 = pxTo3d(el.x1, el.y1);
                        const p2 = pxTo3d(el.x2, el.y2);
                        const thick = (el.thickness || 0.5) * unit;
                        let color = el.color || '#475569';

                        if (el.type === 'door') {
                            const doorH = floorHeight3d * 0.72;
                            const lintelH = floorHeight3d - doorH;
                            const doorW = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));
                            const doorAngle = Math.atan2(p2.z - p1.z, p2.x - p1.x);

                            add3DWall(p1.x, p1.z, p2.x, p2.z, lintelH, thick, color, doorH, el.color2, el.texture);

                            const doorGroup = new THREE.Group();
                            doorGroup.position.set(p1.x, elevation3d, p1.z);
                            doorGroup.rotation.y = -doorAngle;
                            scene3D.add(doorGroup);

                            const frameColor = 0x3e2723;
                            const frameMat = new THREE.MeshStandardMaterial({ color: frameColor, roughness: 0.8 });
                            const frameThick = 2.5;
                            const frameDepth = thick + 2;

                            const jambL = new THREE.Mesh(new THREE.BoxGeometry(frameThick, doorH, frameDepth), frameMat);
                            jambL.position.set(frameThick / 2, doorH / 2, 0);
                            doorGroup.add(jambL);

                            const jambR = new THREE.Mesh(new THREE.BoxGeometry(frameThick, doorH, frameDepth), frameMat);
                            jambR.position.set(doorW - frameThick / 2, doorH / 2, 0);
                            doorGroup.add(jambR);

                            const header = new THREE.Mesh(new THREE.BoxGeometry(doorW, frameThick, frameDepth), frameMat);
                            header.position.set(doorW / 2, doorH - frameThick / 2, 0);
                            doorGroup.add(header);

                            const doorPivot = new THREE.Group();
                            doorPivot.position.set(frameThick, 0, 0);
                            doorGroup.add(doorPivot);

                            const leafW = doorW - (frameThick * 2);
                            const leafH = doorH - frameThick;
                            const leafD = 3;
                            const leafMat = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.6 });
                            const leaf = new THREE.Mesh(new THREE.BoxGeometry(leafW, leafH, leafD), leafMat);
                            leaf.position.set(leafW / 2, leafH / 2, 0);
                            leaf.castShadow = true;
                            doorPivot.add(leaf);

                            const panelGeo = new THREE.BoxGeometry(leafW * 0.7, leafH * 0.35, leafD + 1);
                            const panelMat = new THREE.MeshStandardMaterial({ color: 0x4e342e });
                            const topPanel = new THREE.Mesh(panelGeo, panelMat);
                            topPanel.position.set(leafW / 2, leafH * 0.7, 0);
                            doorPivot.add(topPanel);
                            const botPanel = new THREE.Mesh(panelGeo, panelMat);
                            botPanel.position.set(leafW / 2, leafH * 0.25, 0);
                            doorPivot.add(botPanel);

                            const knobGeo = new THREE.SphereGeometry(2, 16, 16);
                            const knobMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
                            const knob = new THREE.Mesh(knobGeo, knobMat);
                            knob.position.set(leafW - 6, leafH * 0.5, leafD / 2 + 1.5);
                            doorPivot.add(knob);
                            const knob2 = knob.clone();
                            knob2.position.set(leafW - 6, leafH * 0.5, -leafD / 2 - 1.5);
                            doorPivot.add(knob2);

                            animatedElements.push({ type: 'door', pivot: doorPivot, originalAngle: -doorAngle });

                        } else if (el.type === 'window') {
                            const sillH = floorHeight3d * 0.3;
                            const winH = floorHeight3d * 0.4;
                            const headH = floorHeight3d * 0.7;
                            const lintelH = floorHeight3d - headH;
                            const dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.z - p1.z, 2));
                            const ang = Math.atan2(p2.z - p1.z, p2.x - p1.x);

                            add3DWall(p1.x, p1.z, p2.x, p2.z, sillH, thick, color, 0, el.color2, el.texture);
                            add3DWall(p1.x, p1.z, p2.x, p2.z, lintelH, thick, color, headH, el.color2, el.texture);

                            const winGroup = new THREE.Group();
                            winGroup.position.set(p1.x, elevation3d, p1.z);
                            winGroup.rotation.y = -ang;
                            scene3D.add(winGroup);

                            const fColor = 0xffffff;
                            const fMat = new THREE.MeshStandardMaterial({ color: fColor });
                            const fThick = 2;
                            const fDepth = thick + 2;

                            const sill = new THREE.Mesh(new THREE.BoxGeometry(dist, fThick, fDepth + 2), fMat);
                            sill.position.set(dist / 2, sillH + fThick / 2, 0);
                            winGroup.add(sill);

                            const header = new THREE.Mesh(new THREE.BoxGeometry(dist, fThick, fDepth), fMat);
                            header.position.set(dist / 2, headH - fThick / 2, 0);
                            winGroup.add(header);

                            const leftJamb = new THREE.Mesh(new THREE.BoxGeometry(fThick, winH, fDepth), fMat);
                            leftJamb.position.set(fThick / 2, sillH + winH / 2, 0);
                            winGroup.add(leftJamb);

                            const rightJamb = new THREE.Mesh(new THREE.BoxGeometry(fThick, winH, fDepth), fMat);
                            rightJamb.position.set(dist - fThick / 2, sillH + winH / 2, 0);
                            winGroup.add(rightJamb);

                            const glassGeo = new THREE.BoxGeometry(dist - fThick * 2, winH - fThick * 2, 1);
                            const glassMat = new THREE.MeshStandardMaterial({
                                color: 0xa5f2f3, transparent: true, opacity: 0.3, metalness: 0.9, roughness: 0.0, side: THREE.DoubleSide
                            });
                            const glass = new THREE.Mesh(glassGeo, glassMat);
                            glass.position.set(dist / 2, sillH + winH / 2, 0);
                            winGroup.add(glass);

                            const mullion = new THREE.Mesh(new THREE.BoxGeometry(fThick / 2, winH - fThick * 2, 2), fMat);
                            mullion.position.set(dist / 2, sillH + winH / 2, 0);
                            winGroup.add(mullion);

                            // Horizontal Transoms (3 lines: Top, Center, Bottom)
                            const transomGeo = new THREE.BoxGeometry(dist - fThick * 2, fThick / 2, 2);

                            const tBottom = new THREE.Mesh(transomGeo, fMat);
                            tBottom.position.set(dist / 2, sillH + winH * 0.25, 0);
                            winGroup.add(tBottom);

                            const tCenter = new THREE.Mesh(transomGeo, fMat);
                            tCenter.position.set(dist / 2, sillH + winH * 0.5, 0);
                            winGroup.add(tCenter);

                            const tTop = new THREE.Mesh(transomGeo, fMat);
                            tTop.position.set(dist / 2, sillH + winH * 0.75, 0);
                            winGroup.add(tTop);
                        }
                    });

                    // 4. Render Interior Furniture
                    // Calculate Scale Factors for Element Sizing
                    const hw = floor.homeWall || project.floors[0].homeWall;
                    let scaleX = 1, scaleZ = 1;

                    // fW3d and fH3d are already calculated in the parent scope (floor loop)
                    if (hw && hw.width > 0 && hw.height > 0) {
                        scaleX = fW3d / hw.width; // scaling factor for width
                        scaleZ = fH3d / hw.height; // scaling factor for height/depth
                    }

                    symbolElements.forEach(el => {
                        const center = pxTo3d(el.x, el.y);

                        // Safety check for NaN in position
                        if (isNaN(center.x) || isNaN(center.z)) return;

                        const config = symbols[el.symbolType];

                        if (config?.isStair) {
                            create3DStairs_Adjusted(center, el, config, unit, elevation3d, floorHeight3d, walls);
                        } else {
                            create3DFurniture(center, el, config, scaleX, scaleZ, elevation3d, scene3D);
                        }
                    });

                    // 2. Rooms (Outline Fill) - Only fills gaps not covered by elements
                    floor.rooms.forEach(room => {
                        const start = pxTo3d(room.x, room.y);
                        const rW3d = room.length * unit;
                        const rH3d = room.breadth * unit;

                        // Capture Tour Target (Center of Room)
                        tourTargets.push(new THREE.Vector3(start.x + rW3d / 2, elevation3d + (5.5 * 15), start.z + rH3d / 2));

                        // Add 'i' text at the center point
                        const iSprite = createTextSprite('i', 25);
                        iSprite.position.set(start.x + rW3d / 2, elevation3d + (3.5 * 15), start.z + rH3d / 2);
                        scene3D.add(iSprite);

                        const rGeo = new THREE.PlaneGeometry(rW3d, rH3d);
                        const rMat = new THREE.MeshStandardMaterial({ color: room.color, transparent: true, opacity: 0.3 });
                        const rMesh = new THREE.Mesh(rGeo, rMat);
                        rMesh.rotation.x = -Math.PI / 2;
                        rMesh.position.set(start.x + rW3d / 2, elevation3d + 1, start.z + rH3d / 2);
                        scene3D.add(rMesh);

                        // Interior walls are now handled by the main wall processing loop!

                        const indoorLight = new THREE.PointLight(0xfff4e0, 0.4, 300);
                        indoorLight.position.set(start.x + rW3d / 2, elevation3d + floorHeight3d * 0.8, start.z + rH3d / 2);
                        scene3D.add(indoorLight);
                    });
                });

                function getFurnitureHeight(type) {
                    // Returns height in feet (approx)
                    const types = {
                        'wardrobe': 7, 'fridge': 6, 'door': 7, 'shower': 7,
                        'cabinet': 3, 'stove': 3, 'sink': 3, 'washbasin': 3,
                        'table': 2.5, 'dining_table': 2.5, 'sofa': 2.5, 'bench': 2,
                        'bed': 2, 'bed_single': 2, 'toilet': 1.5, 'bathtub': 2,
                        'tv_unit': 2, 'swing': 5, 'lamp': 5, 'plant': 3
                    };
                    return (types[type] || 1) * 15; // 15 units per ft
                }

                function create3DFurniture(center, el, config, scaleX, scaleZ, elevation, scene) {
                    const w = (el.width || config.width) * scaleX;
                    const d = (el.height || config.height) * scaleZ; // 2D height is 3D depth
                    const h = getFurnitureHeight(el.symbolType);
                    const rot = -(el.rotation || 0); // Radians? No, el.rotation is likely degrees if from 2D logic.
                    // Actually 2D rotation usually processed in radians in draw, but let's check. 
                    // The drawElement uses "element.rotation * Math.PI / 180". So it is degrees.
                    const angle = (el.rotation || 0) * Math.PI / 180;

                    const group = new THREE.Group();
                    group.position.set(center.x, elevation + h / 2, center.z);
                    group.rotation.y = -angle;

                    let mesh;
                    const matBody = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White
                    const matIcon = createIconTextureMaterial(config.icon || config.label, w, d);

                    // Multi-material for Box: [Right, Left, Top, Bottom, Front, Back]
                    // We want Icon on TOP (index 2)
                    const materials = [
                        matBody, matBody,
                        matIcon, matBody,
                        matBody, matBody
                    ];

                    if (config.shape === 'circle' || config.shape === 'oval' || config.shape === 'round') {
                        // Cylinder
                        const r = Math.min(w, d) / 2;
                        const geo = new THREE.CylinderGeometry(r, r, h, 32);
                        // Cylinder mapping is diverse, simpler to just put icon on a plane above it or use basic material
                        // For cylinder, top face material index is 1 (side, top, bottom)? Check Threejs docs.
                        // [side, top, bottom] for CylinderGeometry materials array?
                        // Actually Cylinder uses [side, top, bottom]
                        mesh = new THREE.Mesh(geo, [matBody, matIcon, matBody]);
                    } else {
                        // Box (Rect, Bed, etc)
                        const geo = new THREE.BoxGeometry(w, h, d);
                        mesh = new THREE.Mesh(geo, materials);
                    }

                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    group.add(mesh);

                    // Edges (Black Outline)
                    const edges = new THREE.EdgesGeometry(mesh.geometry);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                    mesh.add(line);

                    scene.add(group);
                }

                function createIconTextureMaterial(icon, w, h) {
                    // Create a canvas texture for the top face
                    const canvas = document.createElement('canvas');
                    // Make resolution proportional to aspect ratio
                    const res = 128;
                    canvas.width = res;
                    canvas.height = res * (h / w);
                    // Ensure min height
                    if (canvas.height < 64) {
                        canvas.height = 64;
                        canvas.width = 64 * (w / h);
                    }

                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(0, 0, canvas.width, canvas.height); // White background

                    // Draw Border (optional, already have edges)

                    // Draw Icon
                    ctx.fillStyle = '#000000';
                    const fontSize = Math.min(canvas.width, canvas.height) * 0.8;
                    ctx.font = `${fontSize}px "Material Symbols Outlined"`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // If no icon, maybe label?
                    if (!icon || icon.length > 10) { // arbitrary check for label vs icon code
                        ctx.font = `${fontSize * 0.4}px Arial`;
                        ctx.fillText(icon || '?', canvas.width / 2, canvas.height / 2);
                    } else {
                        ctx.fillText(icon, canvas.width / 2, canvas.height / 2);
                    }

                    const texture = new THREE.CanvasTexture(canvas);
                    return new THREE.MeshStandardMaterial({ map: texture });
                }

                function create3DWall_Old(x1, z1, x2, z2, height, thickness, color) {
                    const dx = x2 - x1;
                    const dz = z2 - z1;
                    const length = Math.sqrt(dx * dx + dz * dz);
                    const angle = Math.atan2(dz, dx);
                    const geo = new THREE.BoxGeometry(length, height, thickness);
                    const mat = new THREE.MeshStandardMaterial({ color: color });
                    const wall = new THREE.Mesh(geo, mat);
                    wall.position.set(x1 + dx / 2, height / 2, z1 + dz / 2); // Note: this needs elevation adjustment in caller
                    wall.rotation.y = -angle;
                    scene3D.add(wall);
                    return wall;
                }

                function create3DStairs_Adjusted(center, element, config, unit, elevation, floorH, walls) {
                    const rot = (element.rotation || 0) * Math.PI / 180;
                    const group = new THREE.Group();
                    group.position.set(center.x, elevation, center.z);
                    group.rotateY(-rot);
                    scene3D.add(group);

                    // Materials
                    const defColor = (typeof project !== 'undefined' && project.defaultWallColor) ? project.defaultWallColor : '#475569';
                    const stepMat = new THREE.MeshStandardMaterial({ color: 0xcbd5e1 });
                    const edgeMat = new THREE.LineBasicMaterial({ color: 0x000000 });
                    const wallMat = new THREE.MeshStandardMaterial({ color: defColor });

                    // Standard step dimensions
                    const stepRise = 7 * (unit / 15);
                    const stepThickness = 2 * (unit / 15);

                    // Hand Wall Config
                    const wallH = 3 * unit;
                    const wallT = 0.3 * unit;

                    // Adjacency Check (Straight Only)
                    const checkSide = (side) => {
                        if (!walls || config.stairType !== 'straight') return false;
                        const widthFt = element.width || config.width;
                        const wPx = widthFt * unit;
                        const cx = element.x + wPx / 2;
                        const lengthFt = element.length || config.length;
                        const lPx = lengthFt * unit;
                        const cy = element.y + lPx / 2;

                        const offset = (side === 'left' ? -wPx / 2 : wPx / 2);
                        const ang = (element.rotation || 0) * Math.PI / 180;
                        const mx = offset * Math.cos(ang);
                        const my = offset * Math.sin(ang);
                        const px = cx + mx;
                        const py = cy + my;

                        return walls.some(w => {
                            const wx1 = w.x1, wy1 = w.y1, wx2 = w.x2, wy2 = w.y2;
                            const l2 = (wx2 - wx1) ** 2 + (wy2 - wy1) ** 2;
                            if (l2 === 0) return false;
                            let t = ((px - wx1) * (wx2 - wx1) + (py - wy1) * (wy2 - wy1)) / l2;
                            t = Math.max(0, Math.min(1, t));
                            const dx = px - (wx1 + t * (wx2 - wx1));
                            const dy = py - (wy1 + t * (wy2 - wy1));
                            return (dx * dx + dy * dy) < 625; // 25px threshold
                        });
                    };
                    const hasLeftWall = checkSide('left');
                    const hasRightWall = checkSide('right');

                    if (config.stairType === 'straight') {
                        const w = (element.width || config.width) * unit;
                        const l = (element.length || config.length) * unit;
                        const steps = element.steps || 10;
                        const stepTread = l / steps;

                        for (let i = 0; i < steps; i++) {
                            const currentHeight = i * stepRise;
                            const stepGeo = new THREE.BoxGeometry(w, stepThickness, stepTread);
                            const step = new THREE.Mesh(stepGeo, stepMat);
                            step.position.set(0, currentHeight + stepThickness / 2, -l / 2 + stepTread / 2 + (i * stepTread));
                            step.castShadow = true;
                            step.receiveShadow = true;
                            const edges = new THREE.EdgesGeometry(stepGeo);
                            const line = new THREE.LineSegments(edges, edgeMat);
                            step.add(line);
                            group.add(step);
                        }

                        // Hand Walls (Parapets)
                        const totalRise = steps * stepRise;
                        const slope = Math.atan2(totalRise, l);
                        const wallLen = Math.sqrt(totalRise ** 2 + l ** 2) + stepTread;
                        const hwGeo = new THREE.BoxGeometry(wallT, wallH, wallLen);

                        // Left Wall
                        if (!hasLeftWall) {
                            const hwL = new THREE.Mesh(hwGeo, wallMat);
                            hwL.position.set(-w / 2 - wallT / 2, totalRise / 2 + wallH / 2 - stepRise, 0);
                            hwL.rotation.x = -slope;
                            hwL.castShadow = true;
                            group.add(hwL);
                        }

                        // Right Wall
                        if (!hasRightWall) {
                            const hwR = new THREE.Mesh(hwGeo, wallMat);
                            hwR.position.set(w / 2 + wallT / 2, totalRise / 2 + wallH / 2 - stepRise, 0);
                            hwR.rotation.x = -slope;
                            hwR.castShadow = true;
                            group.add(hwR);
                        }

                    } else if (config.stairType === 'lshape') {
                        const w = (element.width || config.width) * unit;
                        const l = (element.length || config.length) * unit;
                        const b = (element.breadth || config.breadth) * unit;
                        const steps = element.steps || 12;
                        const steps1 = Math.floor(steps / 2);
                        const stepTread1 = l / steps1;

                        // First run (vertical)
                        for (let i = 0; i < steps1; i++) {
                            const currentHeight = i * stepRise;
                            const stepGeo = new THREE.BoxGeometry(w, stepThickness, stepTread1);
                            const step = new THREE.Mesh(stepGeo, stepMat);
                            step.position.set(0, currentHeight + stepThickness / 2, l / 2 - stepTread1 / 2 - (i * stepTread1));
                            step.castShadow = true;
                            step.receiveShadow = true;
                            const edges = new THREE.EdgesGeometry(stepGeo);
                            const line = new THREE.LineSegments(edges, edgeMat);
                            step.add(line);
                            group.add(step);
                        }

                        // Hand Wall 1
                        const rise1 = steps1 * stepRise;
                        const slope1 = Math.atan2(rise1, l);
                        const len1 = Math.sqrt(rise1 ** 2 + l ** 2) + stepTread1;
                        const hw1Geo = new THREE.BoxGeometry(wallT, wallH, len1);

                        // Left 1
                        const hw1L = new THREE.Mesh(hw1Geo, wallMat);
                        hw1L.position.set(-w / 2 - wallT / 2, rise1 / 2 + wallH / 2 - stepRise, 0); // Local center of run is 0,0,0?
                        // Wait, loop uses l/2 ... -l/2. Center is 0.
                        // But Z decreases as Y increases. Slope is negative?
                        // Z goes +l/2 to -l/2. Y goes Up.
                        // Towards -Z is Up.
                        // Normal Slope: +Z = Up.
                        // So here Slope is Reversed.
                        hw1L.rotation.x = slope1; // Positive rot tilts Up towards -Z.
                        group.add(hw1L);

                        // Right 1 (Inner corner needs care, but just overlapping is fine)
                        const hw1R = hw1L.clone();
                        hw1R.position.x = w / 2 + wallT / 2;
                        group.add(hw1R);

                        // Second run (horizontal)
                        const steps2 = steps - steps1;
                        const stepTread2 = (b - w) / steps2;
                        for (let i = 0; i < steps2; i++) {
                            const currentHeight = (steps1 + i) * stepRise;
                            const stepGeo = new THREE.BoxGeometry(stepTread2, stepThickness, w);
                            const step = new THREE.Mesh(stepGeo, stepMat);
                            step.position.set(-w / 2 + w + stepTread2 / 2 + (i * stepTread2), currentHeight + stepThickness / 2, -l / 2 + w / 2);
                            step.castShadow = true;
                            step.receiveShadow = true;
                            const edges = new THREE.EdgesGeometry(stepGeo);
                            const line = new THREE.LineSegments(edges, edgeMat);
                            step.add(line);
                            group.add(step);
                        }

                        // Hand Wall 2
                        const rise2 = steps2 * stepRise;
                        const run2 = b - w;
                        const slope2 = Math.atan2(rise2, run2);
                        const len2 = Math.sqrt(rise2 ** 2 + run2 ** 2) + stepTread2;
                        const hw2Geo = new THREE.BoxGeometry(len2, wallH, wallT); // Oriented along X

                        // Center of Run 2
                        // X start: w/2. X end: w/2 + run2. Mid: w/2 + run2/2.
                        // Y start: rise1. Y end: rise1 + rise2. Mid: rise1 + rise2/2.
                        // Z: -l/2 + w/2.

                        const hw2L = new THREE.Mesh(hw2Geo, wallMat);
                        hw2L.position.set(w / 2 + run2 / 2, rise1 + rise2 / 2 + wallH / 2 - stepRise, -l / 2 + w / 2 - w / 2 - wallT / 2);
                        // Z pos: Top Edge (-l/2 + w/2 is center of step). Center of step Z is fixed.
                        // Inner Edge: -l/2 + w/2 - w/2 = -l/2.
                        // Outer Edge: -l/2 + w/2 + w/2 = -l/2 + w.

                        // Let's place Outer (Bottom)
                        hw2L.position.z = -l / 2 + w + wallT / 2;

                        // Rotation: X increases, Y increases.
                        // Rotate around Z axis (Roll).
                        // +Z rot moves +X Up?
                        // Right Hand Rule on Z: X->Y. Positive Z rot moves X towards Y.
                        // So `rotation.z = slope2` tilts +X up.
                        hw2L.rotation.z = slope2;
                        group.add(hw2L);

                        // Upper (Inner)
                        const hw2R = hw2L.clone();
                        hw2R.position.z = -l / 2 - wallT / 2; // Inner corner
                        group.add(hw2R);

                    } else if (config.stairType === 'spiral') {
                        const r = (element.radius || config.radius) * unit;
                        const steps = config.steps || 12;

                        // Central pole
                        const poleGeo = new THREE.CylinderGeometry(r * 0.1, r * 0.1, floorH, 16);
                        const pole = new THREE.Mesh(poleGeo, stepMat);
                        pole.position.y = floorH / 2;
                        pole.castShadow = true;
                        group.add(pole);

                        // Spiral steps
                        for (let i = 0; i < steps; i++) {
                            const ang = (Math.PI * 2 / steps) * i;
                            const currentHeight = i * stepRise;
                            const stepGeo = new THREE.BoxGeometry(r * 0.9, stepThickness, r * 0.3);
                            const step = new THREE.Mesh(stepGeo, stepMat);
                            step.position.set(Math.cos(ang) * r / 2, currentHeight + stepThickness / 2, Math.sin(ang) * r / 2);
                            step.rotation.y = -ang;
                            step.castShadow = true;
                            step.receiveShadow = true;
                            const edges = new THREE.EdgesGeometry(stepGeo);
                            const line = new THREE.LineSegments(edges, edgeMat);
                            step.add(line);
                            group.add(step);

                            // Hand Wall Segment (Outer)
                            // A vertical panel at the outer tip
                            const panelW = r * 0.35; // slightly wider than tread width at tip
                            const panelGeo = new THREE.BoxGeometry(wallT, wallH + stepRise, panelW);
                            const panel = new THREE.Mesh(panelGeo, wallMat);
                            // Position: Tip of step.
                            // Step center is at r/2. Tip is at r.
                            // We need to rotate panel to be tangent?

                            const radiusTip = r;
                            panel.position.set(Math.cos(ang) * (r - wallT), currentHeight + wallH / 2, Math.sin(ang) * (r - wallT));
                            panel.rotation.y = -ang;
                            group.add(panel);
                        }
                    }
                }

                animate3D();
            }

            function createTextSprite(text, size, fontFamily = 'Arial') {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');

                // Background check for debugging transparency
                // ctx.fillStyle = 'rgba(255,0,0,0.1)';
                // ctx.fillRect(0,0,128,128);

                ctx.font = `80px "${fontFamily}"`;
                ctx.fillStyle = '#000000'; // Black Text
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 64, 64);

                const texture = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(size, size, 1);
                return sprite;
            }

            function animate3D() {
                if (!is3DMode) return;
                function loop() {
                    if (!is3DMode) return;
                    requestAnimationFrame(loop);

                    const delta = clock.getDelta();

                    if (isTouring) {
                        updateTour(delta);
                    } else if (isWalkMode) {
                        updateWalkMotion();
                    } else if (controls3D) {
                        controls3D.update();
                    }

                    if (renderer3D && scene3D && camera3D) {
                        renderer3D.render(scene3D, camera3D);
                    }
                }
                loop();
            }

            function showToast(icon, message) {
                const toast = document.getElementById('toast');
                document.querySelector('.toast-icon').textContent = icon;
                document.getElementById('toastMessage').textContent = message;
                toast.classList.add('active');
                setTimeout(() => toast.classList.remove('active'), 3000);
            }

            init();
            updateFloorUI();
            function updateWallColor(source) {
                const picker = document.getElementById('wallColor');
                const hexInput = document.getElementById('wallColorHex');
                const rgbInput = document.getElementById('wallColorRgb');

                let hex = picker.value;
                let r, g, b;

                // Helper: Hex to RGB
                const hexToRgb = (h) => {
                    let r = 0, g = 0, b = 0;
                    if (h.length === 4) {
                        r = parseInt(h[1] + h[1], 16);
                        g = parseInt(h[2] + h[2], 16);
                        b = parseInt(h[3] + h[3], 16);
                    } else if (h.length === 7) {
                        r = parseInt(h[1] + h[2], 16);
                        g = parseInt(h[3] + h[4], 16);
                        b = parseInt(h[5] + h[6], 16);
                    }
                    return { r, g, b };
                };

                // Helper: RGB to Hex
                const componentToHex = (c) => {
                    const hex = c.toString(16);
                    return hex.length == 1 ? "0" + hex : hex;
                };
                const rgbToHex = (r, g, b) => "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);


                if (source === 'picker') {
                    hex = picker.value;
                    hexInput.value = hex;
                    const rgb = hexToRgb(hex);
                    rgbInput.value = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
                } else if (source === 'hex') {
                    hex = hexInput.value;
                    if (/^#[0-9A-F]{6}$/i.test(hex)) {
                        picker.value = hex;
                        const rgb = hexToRgb(hex);
                        rgbInput.value = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
                    }
                } else if (source === 'rgb') {
                    const parts = rgbInput.value.split(',').map(p => parseInt(p.trim()));
                    if (parts.length === 3 && parts.every(p => !isNaN(p) && p >= 0 && p <= 255)) {
                        hex = rgbToHex(parts[0], parts[1], parts[2]);
                        picker.value = hex;
                        hexInput.value = hex;
                    }
                }

                redrawAll();
                if (is3DMode) init3D();
            }

            function setEnvPreset(preset) {
                if (!preset) return;
                saveState();

                switch (preset) {
                    case 'garden':
                        project.groundTexture = 'grass.avif';
                        project.envTexture = 'sky.avif';
                        if (scene3D) {
                            scene3D.background = new THREE.Color(0x87ceeb);
                        }
                        break;
                    case 'modern':
                        project.groundTexture = ASSETS.tiles;
                        project.envTexture = null;
                        if (scene3D) scene3D.background = new THREE.Color(0xeeeeee);
                        break;
                    case 'sketch':
                        project.groundTexture = null;
                        project.envTexture = null;
                        project.defaultWallColor = '#ffffff';
                        if (scene3D) scene3D.background = new THREE.Color(0xffffff);
                        // Architectural look handled by white background and wireframes (if we had them)
                        break;
                    case 'night':
                        project.groundTexture = null;
                        project.envTexture = null;
                        if (scene3D) {
                            scene3D.background = new THREE.Color(0x0a0a1a);
                            // We would adjust lights here if we had access to them globally
                        }
                        break;
                }

                if (is3DMode) init3D();
                showToast('üåç', `Environment set to ${preset}`);
            }

            function set3DView(view) {
                if (!camera3D || !controls3D) return;
                const unit = 15;
                const dist = Math.max(project.totalLength || 20, project.totalBreadth || 20) * unit * 1.5;

                // Reset walk mode if active
                if (isWalkMode) toggleWalkMode();

                // Stop any running tour
                if (isTouring) toggleTour();

                switch (view) {
                    case 'top':
                        camera3D.position.set(0, dist * 1.5, 0);
                        break;
                    case 'front':
                        camera3D.position.set(0, dist * 0.5, dist);
                        break;
                    case 'side':
                        camera3D.position.set(dist, dist * 0.5, 0);
                        break;
                    case 'iso':
                        camera3D.position.set(dist, dist, dist);
                        break;
                }
                controls3D.target.set(0, 0, 0);
                controls3D.update();
                showToast('üì∏', `${view.toUpperCase()} View set`);
            }

            function updateWallTexture(val) {
                project.defaultWallTexture = val;
                if (is3DMode) init3D();
            }

            function updateFloorHeight(val) {
                const h = parseInt(val);
                if (isNaN(h)) return;
                const activeFloor = project.floors[project.activeFloorIndex];
                activeFloor.height = h;
                if (is3DMode) init3D();
            }

            function updateFloorTexture(val) {
                const activeFloor = project.floors[project.activeFloorIndex];
                activeFloor.floorTexture = val;
                if (is3DMode) init3D();
            }

            function applySelectedTexture(val) {
                if (selectedElement && selectedElement.type === 'wall') {
                    saveState();
                    selectedElement.texture = val;
                    if (is3DMode) init3D();
                    redrawAll();
                }
            }

            function updateSelectedWallColor(source, side) {
                // side is 'inner' or 'outer'
                const picker = document.getElementById(side + 'ColorPicker');
                const hexInput = document.getElementById(side + 'ColorHex');
                const rgbInput = document.getElementById(side + 'ColorRgb');

                // Helpers
                const hexToRgb = (h) => {
                    let r = 0, g = 0, b = 0;
                    if (h.length === 4) {
                        r = parseInt(h[1] + h[1], 16);
                        g = parseInt(h[2] + h[2], 16);
                        b = parseInt(h[3] + h[3], 16);
                    } else if (h.length === 7) {
                        r = parseInt(h[1] + h[2], 16);
                        g = parseInt(h[3] + h[4], 16);
                        b = parseInt(h[5] + h[6], 16);
                    }
                    return { r, g, b };
                };
                const componentToHex = (c) => {
                    const hex = c.toString(16);
                    return hex.length == 1 ? "0" + hex : hex;
                };
                const rgbToHex = (r, g, b) => "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);

                let hex = picker.value;

                if (source === 'picker') {
                    hex = picker.value;
                    hexInput.value = hex;
                    const rgb = hexToRgb(hex);
                    rgbInput.value = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
                } else if (source === 'hex') {
                    hex = hexInput.value;
                    if (/^#[0-9A-F]{6}$/i.test(hex)) {
                        picker.value = hex;
                        const rgb = hexToRgb(hex);
                        rgbInput.value = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
                    }
                } else if (source === 'rgb') {
                    const parts = rgbInput.value.split(',').map(p => parseInt(p.trim()));
                    if (parts.length === 3 && parts.every(p => !isNaN(p) && p >= 0 && p <= 255)) {
                        hex = rgbToHex(parts[0], parts[1], parts[2]);
                        picker.value = hex;
                        hexInput.value = hex;
                    }
                }

                changeSelectedColor(side);
            }

            // --- Collapsible UI Logic ---
            document.addEventListener('click', (e) => {
                const title = e.target.closest('.sidebar-title');
                if (title && title.parentElement.classList.contains('sidebar-section')) {
                    title.parentElement.classList.toggle('collapsed');
                }
            });

            function toggleThreeControls() {
                const overlay = document.getElementById('threeControls');
                const toggleBtn = document.getElementById('threeControlsToggle');
                const isMinimized = overlay.classList.toggle('minimized');

                if (isMinimized) {
                    toggleBtn.style.display = 'block';
                } else {
                    toggleBtn.style.display = 'none';
                    overlay.style.display = 'flex'; // Ensure it's showing if maximizing
                }
            }

        </script>
</body>

</html>
